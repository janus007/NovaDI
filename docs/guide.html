<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Documentation - NovaDI</title>
    <meta name="description"

    <!-- Theme Init - Must load BEFORE CSS to prevent flash -->
    <script>
      (function() {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const savedTheme = localStorage.getItem('theme');
        const theme = savedTheme || (prefersDark ? 'dark' : 'light');
        document.documentElement.setAttribute('data-theme', theme);
      })();
    </script>
      content="Complete Documentation to NovaDI: patterns, lifetimes, testing, and real-world examples.">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Roboto+Slab:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=optional"
      rel="stylesheet">

    <link rel="stylesheet" href="css/docs.css">

    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
      rel="stylesheet">

    <style>
    .sidebar {
      position: sticky;
      top: 80px;
      max-height: calc(100vh - 100px);
      overflow-y: auto;
      padding-right: 20px;
    }

    .sidebar a {
      display: block;
      padding: 6px 12px;
      color: #666;
      text-decoration: none;
      transition: all 0.2s;
      border-left: 2px solid transparent;
    }

    .sidebar a:hover {
      color: #0066cc;
      border-left-color: #0066cc;
    }

    .sidebar a.active {
      color: #0066cc;
      border-left-color: #0066cc;
      font-weight: 500;
    }

    @media (max-width: 968px) {
      .sidebar {
        display: none;
      }
    }
    </style>
  </head>

  <body>
    <!-- Mobile Menu Button -->
    <button class="mobile-menu-button" aria-label="Toggle navigation menu">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>

    <!-- Mobile Menu Backdrop -->
    <div class="mobile-menu-backdrop"></div>

    <!-- Header -->
    <header class="main-header">
      <a href="index.html" class="header-logo">NovaDI</a>
      <div class="header-links">
        <a href="https://www.npmjs.com/package/@novadi/core" target="_blank">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
            <path
              d="M0 7.334v8h6.666v1.332H12v-1.332h12v-8H0zm6.666 6.664H5.334v-4H3.999v4H1.335V8.667h5.331v5.331zm4 0v1.336H8.001V8.667h5.334v5.332h-2.669v-.001zm12.001 0h-1.33v-4h-1.336v4h-1.335v-4h-1.33v4h-2.671V8.667h8.002v5.331zM10.665 10H12v2.667h-1.335V10z">
            </path>
          </svg>
          npm
        </a>
        <a href="https://github.com/janus007/NovaDI" target="_blank">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
            <path
              d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z">
            </path>
          </svg>
          GitHub
        </a>
        <button type="submit" id="theme-toggle" aria-label="Toggle theme">
          <span class="theme-icon">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path
                d="M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z">
              </path>
            </svg>
          </span>
        </button>
      </div>
    </header>

    <!-- Sidebar Navigation -->
    <aside class="main-nav">
      <div class="nav-container">
        <div class="api-search-container">
          <input type="text" class="api-search" placeholder="Search API..." aria-label="Search API">
          <svg class="api-search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"></circle>
            <path d="m21 21-4.35-4.35"></path>
          </svg>
        </div>

        <ul class="nav-links">
          <li class="nav-group">
            <div class="nav-group-title">Documentation</div>
            <a href="getting-started.html">Getting Started</a>
            <a href="guide.html" class="active">Documentation</a>
            <a href="api-reference.html">API Reference</a>
            <a href="why.html">Why is DI this important?</a>
            <a href="design-philosophy.html">Design Philosophy</a>
          </li>
          <li class="nav-group">
            <div class="nav-group-title">Resources</div>
            <a href="roadmap.html">NovaDI Roadmap & Ideas</a>
            <a href="demo.html">Performance Benchmarks</a>
            <a href="examples.html">Examples</a>
          </li>
        </ul>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">

      <!-- Hero Section -->
      <div class="hero">
        <div class="container">
          <h1 class="hero-title">Documentation</h1>
          <p class="hero-subtitle">Decorator-free Dependency Injection for TypeScript</p>
          <div >
            <span class="tech-badge">TypeScript 5+</span>
            <span class="tech-badge">Zero Decorators</span>
            <span class="tech-badge">Browser-First</span>
            <span class="tech-badge">Type-Safe</span>
            <span class="tech-badge">3.9KB gzipped</span>
          </div>
        </div>
      </div>

      <!-- Content -->
      <div class="container" class="py-section">
        <!-- Core Concepts -->
        <section id="core-concepts">
          <h2>Core Concepts</h2>
          <p>
            NovaDI is built around three simple concepts: <strong>Container</strong>, <strong>Builder</strong>, and
            <strong>Convention</strong>.
          </p>
          <p>Inspired by Autofac, built for modern TypeScript projects. Fast, type-safe, and framework-agnostic.</p>
          <h3>Container & Builder</h3>
          <p>The <code>Container</code> stores your service registrations. The <code>Builder</code> configures them:</p>

        <pre class="line-numbers"><code class="language-typescript">import { Container } from '@novadi/core'

// Step 1: Create container
const container = new Container()
const builder = container.builder()

// Step 2: Register services
builder.registerType(MyService).as<IMyService>().singleInstance()

// Step 3: Build and resolve
const app = builder.build()
const service = app.resolveType<IMyService>()</code></pre>

        <div class="callout callout-info" class="my-24">
          <strong>💡 Composition Root Pattern</strong><br>
          All DI configuration should live in ONE place - your application's entry point.
          This is called the "Composition Root" and it's a core principle of clean architecture.
        </div>

        <h3>Registration API</h3>
        <p>Register services with a fluent API:</p>

        <pre class="line-numbers"><code class="language-typescript">// Register implementation to interface
builder.registerType(ConsoleLogger).as<ILogger>()

// Register with lifetime
builder.registerType(Database).as<IDatabase>().singleInstance()

// Register with autowiring
builder.registerType(UserService).as<UserService>().autoWire()

// Chain everything together
builder
  .registerType(PostgresDB)
  .as<IDatabase>()
  .singleInstance()
  .autoWire()</code></pre>
      </section>

      <hr class="my-60">

      <!-- AutoWire -->
      <section id="autowire">
        <h2>AutoWire - Convention Over Configuration</h2>
        <p>
          <strong>Autowiring by convention</strong> is THE way to wire dependencies in NovaDI.
          No manual configuration, no boilerplate - it just works.
        </p>

        <h3>The Standard Way: Type Injection by Convention</h3>
        <pre class="line-numbers"><code class="language-typescript">class UserService {
  constructor(
    private logger: ILogger,      // Automatically resolves ILogger
    private database: IDatabase   // Automatically resolves IDatabase
  ) {}
}

// This is all you need - autowiring by convention!
builder.registerType(UserService).as<UserService>().autoWire()</code></pre>

        <p><strong>How it works:</strong></p>
        <ul class="ml-24 lh-relaxed">
          <li>Extracts parameter names from constructor (<code>logger</code>, <code>database</code>)</li>
          <li>Tries multiple naming conventions: <code>ILogger</code>, <code>Logger</code>, <code>logger</code></li>
          <li>Automatically resolves the matching registered interfaces</li>
          <li><strong>Zero configuration - pure convention!</strong></li>
        </ul>

        <div class="callout callout-success" class="my-24">
          <strong>✅ Best Practice:</strong> Use <code>.autoWire()</code> without arguments for ALL your services.
          This is how NovaDI is meant to be used.
        </div>

        <h3>Explicit Mapping (Edge Cases Only)</h3>
        <p>Only use explicit mapping for rare cases where autowiring can't help:</p>

        <pre class="line-numbers"><code class="language-typescript">builder
  .registerType(SmartLight)
  .as<IDevice>()
  .autoWire({
    map: {
      id: () => 'light-123',              // Primitive value injection
      name: () => 'Living Room Light',    // String injection
      logger: (c) => c.resolveType<ILogger>()  // Custom resolution
    }
  })</code></pre>

        <p><strong>Only use explicit mapping when:</strong></p>
        <ul class="ml-24 lh-relaxed">
          <li>Injecting primitives, strings, or configuration values</li>
          <li>You need custom resolution logic (rare)</li>
          <li>You're NOT using the transformer AND code is minified</li>
        </ul>

        <div class="callout callout-warning" class="my-24">
          <strong>⚠️ For regular service dependencies, ALWAYS use <code>.autoWire()</code> without arguments!</strong>
        </div>
      </section>

      <hr class="my-60">

      <!-- Lifetimes -->
      <section id="lifetimes">
        <h2>Lifetimes</h2>
        <p>
          Lifetimes control when and how instances are created. <strong>Default is singleton</strong> (one instance
          for entire container lifetime).
        </p>

        <h3>Singleton - One Instance Forever (DEFAULT)</h3>
        <pre
          class="line-numbers"><code class="language-typescript">builder.registerType(Database).as<IDatabase>()
// No explicit lifetime = singleton by default</code></pre>
        <p><strong>Use for:</strong> Loggers, database connections, configuration, caches, stateless services, most services</p>
        <ul class="ml-24 lh-relaxed">
          <li>✅ One instance created on first resolution</li>
          <li>✅ Reused for entire application lifetime</li>
          <li>✅ Thread-safe caching</li>
          <li>⚡ Ultra-fast (cached lookup)</li>
        </ul>

        <h3>Transient - New Instance Every Time</h3>
        <pre class="line-numbers"><code class="language-typescript">builder.registerType(RequestHandler).as<IRequestHandler>().instancePerDependency()
// Explicit call needed for transient</code></pre>
        <p><strong>Use for:</strong> Request handlers, commands, stateful operations, short-lived services</p>
        <ul class="ml-24 lh-relaxed">
          <li>✅ Fresh instance on every resolution</li>
          <li>✅ No shared state between uses</li>
          <li>✅ Safe for concurrent operations</li>
        </ul>

        <h3>Per-Request - One Instance Per Resolution Tree</h3>
        <pre
          class="line-numbers"><code class="language-typescript">builder.registerType(UnitOfWork).as<IUnitOfWork>().instancePerRequest()</code></pre>
        <p><strong>Use for:</strong> Database transactions, request-scoped state, HTTP request context</p>
        <ul class="ml-24 lh-relaxed">
          <li>✅ One instance per resolution tree</li>
          <li>✅ Shared across dependencies in same resolve call</li>
          <li>✅ New instance for next top-level resolution</li>
          <li>💡 Perfect for transactions that span multiple services</li>
        </ul>

        <div class="callout callout-info" class="my-24">
          <strong>💡 Choosing the Right Lifetime:</strong><br>
          <ul class="my-8 ml-24 lh-relaxed">
            <li><strong>Singleton (default):</strong> Can it be safely shared? → Yes → Use default</li>
            <li><strong>Transient:</strong> Does it hold state or need isolation? → Yes → .instancePerDependency()</li>
            <li><strong>Per-Request:</strong> Needs to be shared in one operation? → Yes → .instancePerRequest()</li>
          </ul>
        </div>
      </section>

      <hr class="my-60">

      <!-- Real-World Example -->
      <section id="real-world">
        <h2>Real-World Example</h2>
        <p>A complete example showing typical application architecture:</p>

        <pre class="line-numbers"><code class="language-typescript">import { Container } from '@novadi/core'

// Services (clean code, no framework imports!)
interface ILogger {
  info(message: string): void
  error(message: string, error?: Error): void
}

class ConsoleLogger implements ILogger {
  info(message: string) {
    console.log(`[INFO] ${message}`)
  }
  error(message: string, error?: Error) {
    console.error(`[ERROR] ${message}`, error)
  }
}

interface IDatabase {
  query<T>(sql: string): Promise<T[]>
}

class PostgresDatabase implements IDatabase {
  constructor(private logger: ILogger) {}

  async query<T>(sql: string): Promise<T[]> {
    this.logger.info(`Executing query: ${sql}`)
    // Implementation...
    return []
  }
}

interface IEmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>
}

class EmailService implements IEmailService {
  constructor(private logger: ILogger) {}

  async sendEmail(to: string, subject: string, body: string) {
    this.logger.info(`Sending email to ${to}`)
    // Implementation...
  }
}

class UserService {
  constructor(
    private database: IDatabase,
    private emailService: IEmailService,
    private logger: ILogger
  ) {}

  async createUser(email: string, name: string) {
    this.logger.info(`Creating user: ${name}`)

    // Save to database
    await this.database.query(`INSERT INTO users...`)

    // Send welcome email
    await this.emailService.sendEmail(
      email,
      'Welcome!',
      `Hello ${name}!`
    )
  }
}

// ========================================
// Composition Root - ALL config in ONE place
// ========================================
const container = new Container()
const builder = container.builder()

// Infrastructure (singletons - shared across app)
builder.registerType(ConsoleLogger).as<ILogger>().singleInstance()
builder.registerType(PostgresDatabase).as<IDatabase>().singleInstance().autoWire()
builder.registerType(EmailService).as<IEmailService>().singleInstance().autoWire()

// Application services (transient by default)
builder.registerType(UserService).as<UserService>().autoWire()

const app = builder.build()

// Use it
const userService = app.resolveType<UserService>()
await userService.createUser('alice@example.com', 'Alice')</code></pre>

        <p><strong>Notice:</strong></p>
        <ul class="ml-24 lh-relaxed">
          <li>✅ All service files are pure TypeScript - no decorators, no framework imports</li>
          <li>✅ <code>.autoWire()</code> handles ALL dependency wiring by convention</li>
          <li>✅ No manual mapping needed - it just works</li>
          <li>✅ Configuration lives in ONE place (Composition Root)</li>
          <li>✅ Testing is trivial: <code>new UserService(mockDB, mockEmail, mockLogger)</code></li>
        </ul>
      </section>

      <hr class="my-60">

      <!-- Transformer Magic -->
      <section id="transformer">
        <h2>Transformer Magic</h2>
        <p>
          The TypeScript transformer is what makes NovaDI's clean API possible. It automatically injects
          type names at compile-time.
        </p>

        <h3>What the Transformer Does</h3>
        <pre class="line-numbers"><code class="language-typescript">// You write:
builder.registerType(ConsoleLogger).as<ILogger>().singleInstance()
const logger = app.resolveType<ILogger>()

// Transformer generates:
builder.registerType(ConsoleLogger).as<ILogger>("ILogger").singleInstance()
const logger = app.resolveType<ILogger>("ILogger")</code></pre>

        <div class="callout callout-success" class="my-24">
          <strong>✅ Benefits:</strong>
          <ul class="my-8 ml-24 lh-relaxed">
            <li>Compile-time validation of all dependencies</li>
            <li>Zero typo risk - TypeScript checks everything</li>
            <li>Refactoring safety - rename types freely</li>
            <li>Future: Dependency graph generation, missing registration detection</li>
          </ul>
        </div>

        <h3>Bundler Compatibility</h3>
        <p>The transformer works across all major bundlers via <strong>unplugin</strong>:</p>

        <table class="full-width my-24">
          <thead>
            <tr >
              <th class="p-12 text-left">Bundler</th>
              <th class="p-12 text-left">Status</th>
              <th class="p-12 text-left">Method</th>
            </tr>
          </thead>
          <tbody>
            <tr >
              <td class="p-12"><strong>Vite</strong></td>
              <td class="p-12">✅ Works</td>
              <td class="p-12">unplugin</td>
            </tr>
            <tr >
              <td class="p-12"><strong>webpack</strong></td>
              <td class="p-12">✅ Works</td>
              <td class="p-12">unplugin</td>
            </tr>
            <tr >
              <td class="p-12"><strong>Rollup</strong></td>
              <td class="p-12">✅ Works</td>
              <td class="p-12">unplugin or ts-patch</td>
            </tr>
            <tr >
              <td class="p-12"><strong>esbuild</strong></td>
              <td class="p-12">✅ Works</td>
              <td class="p-12">unplugin</td>
            </tr>
            <tr >
              <td class="p-12"><strong>tsc</strong></td>
              <td class="p-12">✅ Works</td>
              <td class="p-12">ts-patch</td>
            </tr>
          </tbody>
        </table>

        <p>See <a href="getting-started.html#manual-setup">Getting Started</a> for setup instructions.</p>
      </section>

      <hr class="my-60">

      <!-- Testing -->
      <section id="testing">
        <h2>Testing Strategies</h2>
        <p>
          One of NovaDI's biggest advantages: your business logic is <strong>completely framework-free</strong>,
          making testing trivially easy.
        </p>

        <h3>Unit Testing (No Container Needed)</h3>
        <pre class="line-numbers"><code class="language-typescript">import { describe, it, expect, vi } from 'vitest'

describe('UserService', () => {
  it('should create user and send welcome email', async () => {
    // Create mocks (no framework, just plain TypeScript!)
    const mockDB: IDatabase = {
      query: vi.fn().mockResolvedValue([])
    }

    const mockEmail: IEmailService = {
      sendEmail: vi.fn().mockResolvedValue(undefined)
    }

    const mockLogger: ILogger = {
      info: vi.fn(),
      error: vi.fn()
    }

    // Instantiate directly - no container needed!
    const service = new UserService(mockDB, mockEmail, mockLogger)

    // Test
    await service.createUser('alice@example.com', 'Alice')

    // Assert
    expect(mockDB.query).toHaveBeenCalled()
    expect(mockEmail.sendEmail).toHaveBeenCalledWith(
      'alice@example.com',
      'Welcome!',
      'Hello Alice!'
    )
  })
})</code></pre>

        <div class="callout callout-success" class="my-24">
          <strong>✅ This is why "no decorators" matters!</strong><br>
          Your services are just TypeScript classes. No framework coupling. No special test setup. Just pure, testable
          code.
        </div>

        <h3>Integration Testing (With Container)</h3>
        <pre class="line-numbers"><code class="language-typescript">describe('UserService Integration', () => {
  it('should work with real container', async () => {
    // Build test container
    const container = new Container()
    const builder = container.builder()

    // Register with test implementations
    builder.registerType(InMemoryDatabase).as<IDatabase>().singleInstance()
    builder.registerType(MockEmailService).as<IEmailService>().singleInstance()
    builder.registerType(ConsoleLogger).as<ILogger>().singleInstance()
    builder.registerType(UserService).as<UserService>().autoWire()

    const app = builder.build()

    // Resolve and test
    const service = app.resolveType<UserService>()
    await service.createUser('bob@example.com', 'Bob')

    // Assert using test implementations
    const db = app.resolveType<IDatabase>() as InMemoryDatabase
    expect(db.users).toHaveLength(1)
  })
})</code></pre>
      </section>

      <hr class="my-60">

      <!-- Common Patterns -->
      <section id="patterns">
        <h2>Common Patterns</h2>

        <h3>Factory Pattern</h3>
        <pre class="line-numbers"><code class="language-typescript">// Register factory function
builder.registerFactory<IConfig>(() => {
  return loadConfigFromFile('./config.json')
}, 'IConfig').singleInstance()

// Use in services
class MyService {
  constructor(private config: IConfig) {}
}</code></pre>

        <h3>Module Pattern</h3>
        <pre class="line-numbers"><code class="language-typescript">// Define reusable modules
const databaseModule = (builder: Builder) => {
  builder.registerType(PostgresDB).as<IDatabase>().singleInstance()
  builder.registerType(RedisCache).as<ICache>().singleInstance()
}

const emailModule = (builder: Builder) => {
  builder.registerType(SendGridService).as<IEmailService>().singleInstance()
}

// Apply modules
databaseModule(builder)
emailModule(builder)</code></pre>

        <h3>Conditional Registration</h3>
        <pre class="line-numbers"><code class="language-typescript">// Different implementations based on environment
if (process.env.NODE_ENV === 'production') {
  builder.registerType(ProductionLogger).as<ILogger>().singleInstance()
} else {
  builder.registerType(DevLogger).as<ILogger>().singleInstance()
}</code></pre>
      </section>

      <hr class="my-60">

      <!-- Troubleshooting -->
      <section id="troubleshooting">
        <h2>Troubleshooting</h2>

        <h3>Common Issues</h3>

        <div class="callout callout-warning" class="my-24">
          <strong>❌ Error: "No binding found for interface XYZ"</strong><br>
          <strong>Cause:</strong> You're trying to resolve an interface that wasn't registered.<br>
          <strong>Fix:</strong> Make sure you called <code>.registerType(...).as<XYZ>()</code> before building.
        </div>

        <div class="callout callout-warning" class="my-24">
          <strong>❌ Error: "Circular dependency detected"</strong><br>
          <strong>Cause:</strong> Service A depends on B, B depends on C, C depends on A.<br>
          <strong>Fix:</strong> Refactor to break the cycle. Consider using events, callbacks, or redesigning
          responsibilities.
        </div>

        <div class="callout callout-warning" class="my-24">
          <strong>❌ Transformer not working (type names not injected)</strong><br>
          <strong>Cause:</strong> Transformer not configured correctly.<br>
          <strong>Fix:</strong> Check <a href="getting-started.html#manual-setup">setup Documentation</a>. For unplugin,
          make sure plugin is in config. For ts-patch, run <code>npx ts-patch install</code>.
        </div>

        <h3>Debugging Tips</h3>
        <pre class="line-numbers"><code class="language-typescript">// Check what's registered
console.log('Building container...')
const app = builder.build()
console.log('Container built successfully!')

// Check resolution
try {
  const service = app.resolveType<IMyService>()
  console.log('Service resolved:', service)
} catch (error) {
  console.error('Resolution failed:', error)
}</code></pre>
      </section>

      <hr class="my-60">

      <!-- Next Steps -->
      <section>
        <h2>🚀 Next Steps</h2>
        <div
          >
          <div class="card">
            <h4>🏗️ Design Philosophy</h4>
            <p>Understand the "why" behind NovaDI's architecture</p>
            <a href="design.html">Read Design Doc →</a>
          </div>
          <div class="card">
            <h4>💻 GitHub</h4>
            <p>View source code, examples, and contribute</p>
            <a href="https://github.com/janus007/NovaDI">View on GitHub →</a>
          </div>
          <div class="card">
            <h4>📦 NPM</h4>
            <p>Latest version and package details</p>
            <a href="https://www.npmjs.com/package/@novadi/core">View on NPM →</a>
          </div>
        </div>
      </section>

    </div>

  </main>

  <!-- Footer -->
  <footer class="main-footer">
    <div class="container">
      <p>
        <a href="https://github.com/janus007/NovaDI">View on GitHub</a> •
        <a href="https://www.npmjs.com/package/@novadi/core">npm</a> •
        <a href="https://github.com/janus007/NovaDI/issues">Report Issue</a>
      </p>
      <p class="text-secondary">Built with ❤️ for TypeScript developers</p>
    </div>
  </footer>

  <!-- Prism.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

  <script>
    // Main navigation sub-links active state on scroll
    const sections = document.querySelectorAll('section[id]');
    const navSubLinks = document.querySelectorAll('.nav-sub-links a');

    window.addEventListener('scroll', () => {
      let current = '';
      sections.forEach(section => {
        const sectionTop = section.offsetTop;
        if (window.pageYOffset >= sectionTop - 150) {
          current = section.getAttribute('id');
        }
      });

      // Update main nav sub-links
      navSubLinks.forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('href') === `#${current}`) {
          link.classList.add('active');
        }
      });
    });
  </script>

  <!-- Docs JavaScript -->
  <script src="js/docs.js"></script>
</body>

</html>