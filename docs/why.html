<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Why is DI this important? - NovaDI</title>
  <meta name="description" content="Understanding why dependency injection matters for TypeScript projects.">

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Roboto+Slab:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="css/docs.css">

  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
</head>
<body>

  <!-- Header -->
  <header class="main-header">
    <a href="index.html" class="header-logo">NovaDI</a>
    <div class="header-links">
      <a href="https://www.npmjs.com/package/@novadi/core" target="_blank" rel="noopener noreferrer">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M0 7.334v8h6.666v1.332H12v-1.332h12v-8H0zm6.666 6.664H5.334v-4H3.999v4H1.335V8.667h5.331v5.331zm4 0v1.336H8.001V8.667h5.334v5.332h-2.669v-.001zm12.001 0h-1.33v-4h-1.336v4h-1.335v-4h-1.33v4h-2.671V8.667h8.002v5.331zM10.665 10H12v2.667h-1.335V10z"></path></svg>
        npm
      </a>
      <a href="https://github.com/janus007/NovaDI" target="_blank" rel="noopener noreferrer">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>
        GitHub
      </a>
      <button id="theme-toggle" aria-label="Toggle theme">
        <span class="theme-icon">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z"></path></svg>
        </span>
      </button>
    </div>
  </header>

  <!-- Sidebar Navigation -->
  <aside class="main-nav">
    <div class="nav-container">
      <ul class="nav-links">
        <li class="nav-group">
          <div class="nav-group-title">Documentation</div>
          <a href="getting-started.html">Getting Started</a>
          <a href="guide.html">Documentation</a>
          <a href="why.html" class="active">Why is DI this important?</a>
          <a href="design-philosophy.html">Design Philosophy</a>
        </li>
        <li class="nav-group">
          <div class="nav-group-title">Resources</div>
          <a href="roadmap.html">NovaDI Roadmap & Ideas</a>
          <a href="demo.html">Performance Benchmarks</a>
          <a href="examples.html">Examples</a>
        </li>
      </ul>
    </div>
  </aside>

  <!-- Main Content -->
  <main class="main-content">
    <!-- Hero Section -->
  <div class="hero">
    <div class="container">
      <h1 class="hero-title">Why is DI this important?</h1>
      <p class="hero-subtitle">Understanding the value of dependency injection</p>
      <div style="margin-top: 24px;">
        <span class="tech-badge">Convention over Configuration</span>
        <span class="tech-badge">Testability</span>
        <span class="tech-badge">Security by Design</span>
        <span class="tech-badge">DRY Principle</span>
      </div>
    </div>
  </div>

  <!-- Content -->
  <div class="container" style="padding: 40px 20px 80px;">

    <!-- Introduction -->
    <section class="section">
      <p class="text-large text-center" style="max-width: 800px; margin: 0 auto 48px;">
        Dependency Injection isn't just a fancy pattern - it's the difference between maintainable, testable code
        and a tangled mess that breaks every time you make a change.
      </p>

      <div class="info-box" style="margin-top: 32px;">
        <h3 style="margin-top: 0;">Built on Proven Principles</h3>
        <p>
          NovaDI is inspired by <strong>Autofac</strong> (the renowned .NET DI container) and the teachings of
          <strong>Mark Seemann</strong>, author of "Dependency Injection in .NET" and one of the world's leading
          experts on DI patterns and practices.
        </p>
        <p>
          Mark Seemann advocates for several key principles that NovaDI follows religiously:
        </p>
        <ul style="margin: 16px 0 0 20px; color: var(--text-secondary); line-height: 1.8;">
          <li>
            <strong>The Composition Root Pattern:</strong> All DI configuration must be in ONE place at your
            application's entry point. NovaDI enforces this - you configure everything in your composition root,
            not scattered across your codebase.
          </li>
          <li>
            <strong>Constructor Injection:</strong> Dependencies should be explicitly declared in constructors,
            making them visible and testable. NovaDI uses constructor injection exclusively - no property injection,
            no hidden dependencies.
          </li>
          <li>
            <strong>Don't Pollute Domain Code with Infrastructure:</strong> Your business logic should have zero
            knowledge of the DI framework. NovaDI achieves this by requiring zero decorators in your domain code -
            no <code>@Injectable()</code>, no framework imports in your services.
          </li>
          <li>
            <strong>Convention over Configuration:</strong> Reduce boilerplate and potential errors by following
            naming conventions. NovaDI's <code>.autoWire()</code> automatically matches constructor parameters
            to registered interfaces by name.
          </li>
          <li>
            <strong>Explicit Lifetime Management:</strong> Be deliberate about object lifetimes (Singleton, Transient, Scoped).
            NovaDI provides clear lifetime options: <code>.singleInstance()</code>, <code>.instancePerRequest()</code>,
            and <code>.instancePerLifetimeScope()</code>.
          </li>
        </ul>
        <p style="margin-top: 16px; margin-bottom: 0;">
          By following these battle-tested principles from the .NET ecosystem, NovaDI brings enterprise-grade
          dependency injection patterns to TypeScript.
        </p>
      </div>
    </section>

    <!-- The Problem -->
    <section class="section">
      <h2>The Problem: Manual Instantiation</h2>
      <p>
        Let's say you're building a real application. You have a <code>UserService</code> that needs to call a backend API,
        handle user repo and send emails. Without DI, you're stuck creating everything manually.
      </p>

      <div class="card" style="margin: 24px 0;">
        <h3>‚ùå Without DI - The Nightmare</h3>
        <pre class="line-numbers"><code class="language-typescript">// Every single place that needs UserService has to know ALL its dependencies
const apiConfig = {
  baseUrl: process.env.API_BASE_URL,
  apiKey: process.env.API_KEY,
  timeout: 5000
}

const httpClient = new FetchHttpClient(apiConfig)
const emailService = new EmailService('smtp.gmail.com', 587, 'user@example.com', 'password123')
const userApi = new UserApi(httpClient)
const userRepository = new UserRepository(userApi)

/***********
in this example we are injecting dependencies, sometimes code is 
written in such a way that UserService instantiates userRepository and emailService 
(which is an even bigger problem, because then it is impossible to test)
***********
*/
const userService = new UserService(userRepository, emailService)

// Now imagine doing having this pattern in 15 different files...
// Good luck testing this without mocking all HTTP calls.</code></pre>

        <div class="info-box info-box-error" style="margin-top: 16px; margin-bottom: 0;">
          <strong>Problems:</strong>
          <ul style="margin: 12px 0 0 20px; color: var(--text-secondary);">
            <li>API keys and secrets scattered everywhere in your code</li>
            <li>Every file needs to know the entire dependency tree</li>
            <li>Impossible to test without hitting real API endpoints</li>
            <li>One constructor change breaks dozens of files</li>
            <li>No way to swap implementations (production vs test vs mock)</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <h3>‚úÖ With DI - Clean and Simple</h3>

        <h4 style="margin-top: 0;">Your Business Code (Clean!)</h4>
        <pre class="line-numbers"><code class="language-typescript">// Anywhere in your code - just ask for what you need
class UserService {
  constructor(
    private userRepo: IUserRepository,
    private emailService: IEmailService
  ) {}
}

// That's it. No API keys. No configuration. No mess.
// Just declare what you need in the constructor.</code></pre>

        <h4 style="margin-top: 24px;">Configuration (ONE Place, ONE Time)</h4>
        <pre class="line-numbers"><code class="language-typescript">// composition-root.ts - ALL secrets and wiring in ONE file
import { Container } from '@novadi/core'

const container = new Container()
const builder = container.builder()

// Configuration from environment
const apiConfig = {
  baseUrl: process.env.API_BASE_URL,
  apiKey: process.env.API_KEY,
  timeout: 5000
}

// Register services
builder.registerInstance(apiConfig).as<HttpConfig>()

builder.registerType(FetchHttpClient).as<IHttpClient>().autoWire().singleInstance()

builder.registerType(EmailService)
  .as<IEmailService>()
  .autoWire({
    map: { //this is just an example of explicit mapping, you would probably do it the same way as apiConfig
      smtp: () => emailConfig.smtp,
      port: () => emailConfig.port,
      user: () => emailConfig.user,
      password: () => emailConfig.password
    }
  })
  .singleInstance()

builder.registerType(UserApi).as<IUserApi>().autoWire().singleInstance()
builder.registerType(UserRepository).as<IUserRepository>().autoWire()
builder.registerType(UserService).as<IUserService>().autoWire()

export const app = builder.build()

// Now use it
const userService = app.resolveType<IUserService>()
// Everything wired automatically! ‚ú®</code></pre>

        <div class="info-box info-box-tip" style="margin-top: 16px; margin-bottom: 0;">
          <strong>Benefits:</strong>
          <ul style="margin: 12px 0 0 20px; color: var(--text-secondary);">
            <li><strong>Secrets in ONE place:</strong> All API keys and passwords in composition root (or .env)</li>
            <li><strong>Clean business code:</strong> Controllers and services have zero configuration</li>
            <li><strong>Easy testing:</strong> Just pass mock implementations to constructors</li>
            <li><strong>Convention-based wiring:</strong> <code>.autoWire()</code> handles dependencies automatically</li>
            <li><strong>Swap implementations:</strong> Change from production to test config in one line</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Convention Over Configuration -->
    <section class="section">
      <h2>Why Conventions Matter</h2>
      <p>
        Most DI frameworks require decorators in your domain code and manual injection tokens.
        NovaDI takes a different approach: <strong>Convention over Configuration</strong>.
      </p>

      <div class="grid grid-2" style="margin: 32px 0;">
        <div class="card" style="border-left: 3px solid var(--accent-red);">
          <h3 style="color: var(--accent-red); margin-top: 0;">‚ùå Token-Based DI (some random)</h3>
          <pre class="line-numbers" style="margin: 0;"><code class="language-typescript">// tokens.ts - Separate file for all injection tokens
const TYPES = {
  IUserRepository: Symbol.for('IUserRepository'),
  IEmailService: Symbol.for('IEmailService'),
  ILogger: Symbol.for('ILogger'),
  IOrderRepository: Symbol.for('IOrderRepository'),
  IUserService: Symbol.for('IUserService'),
  IPaymentService: Symbol.for('IPaymentService')
}

// Domain code - imports + decorators + tokens everywhere
import { injectable, inject } from 'random-di'
import { TYPES } from './tokens'

@injectable()
class UserService {
  constructor(
    @inject(TYPES.IUserRepository) private userRepo: IUserRepository,
    @inject(TYPES.IEmailService) private emailService: IEmailService,
    @inject(TYPES.ILogger) private logger: ILogger
  ) {}
}

@injectable()
class OrderService {
  constructor(
    @inject(TYPES.IOrderRepository) private orderRepo: IOrderRepository,
    @inject(TYPES.IUserService) private userService: IUserService,
    @inject(TYPES.IPaymentService) private paymentService: IPaymentService,
    @inject(TYPES.ILogger) private logger: ILogger
  ) {}
}

// Configuration - bind every token manually
container.bind(TYPES.IUserRepository).to(UserRepository)
container.bind(TYPES.IEmailService).to(EmailService)
container.bind(TYPES.ILogger).to(ConsoleLogger)
container.bind(TYPES.IUserService).to(UserService)
container.bind(TYPES.IOrderRepository).to(OrderRepository)
container.bind(TYPES.IPaymentService).to(PaymentService)</code></pre>
        </div>

        <div class="card" style="border-left: 3px solid var(--accent-teal);">
          <h3 style="color: var(--accent-teal); margin-top: 0;">‚úÖ Convention-Based (NovaDI)</h3>
          <pre class="line-numbers"><code class="language-typescript">// Clean domain code - NO decorators!
class UserService {
  constructor(
    private userRepo: IUserRepository,
    private emailService: IEmailService,
    private logger: ILogger
  ) {}
}

class OrderService {
  constructor(
    private orderRepo: IOrderRepository,
    private userService: IUserService,
    private paymentService: IPaymentService,
    private logger: ILogger
  ) {}
}

// Configuration - conventions handle the wiring
builder.registerType(UserRepository).as<IUserRepository>()
builder.registerType(EmailService).as<IEmailService>()
builder.registerType(ConsoleLogger).as<ILogger>()
builder.registerType(UserService).as<IUserService>().autoWire()
builder.registerType(OrderRepository).as<IOrderRepository>()
builder.registerType(PaymentService).as<IPaymentService>()
builder.registerType(OrderService).as<IOrderService>().autoWire()

// Parameters automatically match registered interfaces by name!
// userRepo ‚Üí IUserRepository, emailService ‚Üí IEmailService, etc.</code></pre>
        </div>
      </div>

      <div class="info-box info-box-info">
        <h5 class="info-box-title">üí° How Conventions Work</h5>
        <p>
          NovaDI matches constructor parameters to registered interfaces by naming convention.
          A parameter named <code>userRepo</code> automatically resolves <code>IUserRepository</code>.
          A parameter named <code>logger</code> resolves <code>ILogger</code>.
        </p>
        <p style="margin-bottom: 0;">
          <strong>Result:</strong> Less configuration, fewer bugs, cleaner code.
        </p>
      </div>
    </section>

    <!-- Real-World Example -->
    <section class="section">
      <h2>Real-World Example: Complex Object Graph</h2>
      <p>
        Let's build a complete application with HTTP API calls, caching, email, and business logic.
        Watch how DI keeps everything clean and manageable.
      </p>

      <div class="card">
        <h3>Step 1: Define Your Domain (No DI Knowledge Required)</h3>
        <pre class="line-numbers"><code class="language-typescript">// Domain interfaces - clean, framework-agnostic
interface ILogger {
  log(message: string): void
  error(message: string): void
}

interface IHttpClient {
  get<T>(url: string, options?: RequestOptions): Promise<T>
  post<T>(url: string, data: any, options?: RequestOptions): Promise<T>
  put<T>(url: string, data: any, options?: RequestOptions): Promise<T>
  delete<T>(url: string, options?: RequestOptions): Promise<T>
}

interface ICache {
  get(key: string): Promise<any>
  set(key: string, value: any, ttl?: number): Promise<void>
}

interface IEmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>
}

interface IUserApi {
  getUser(id: string): Promise<User>
  createUser(data: CreateUserDto): Promise<User>
}

interface IUserRepository {
  findById(id: string): Promise<User>
  save(user: User): Promise<void>
}

interface IUserService {
  getUser(id: string): Promise<User>
  createUser(email: string, name: string): Promise<User>
}</code></pre>

        <h3 style="margin-top: 32px;">Step 2: Implement Services (Still No DI!)</h3>
        <pre class="line-numbers"><code class="language-typescript">// Implementations - just declare what you need in the constructor
class ConsoleLogger implements ILogger {
  log(message: string) { console.log(`[LOG] ${message}`) }
  error(message: string) { console.error(`[ERROR] ${message}`) }
}

class FetchHttpClient implements IHttpClient {
  constructor(
    private config: HttpConfig,
    private logger: ILogger
  ) {}

  async get<T>(url: string, options?: RequestOptions): Promise<T> {
    this.logger.log(`GET ${this.config.baseUrl}${url}`)
    const response = await fetch(`${this.config.baseUrl}${url}`, {
      headers: { 'Authorization': `Bearer ${this.config.apiKey}` }
    })
    return response.json()
  }

  async post<T>(url: string, data: any): Promise<T> { /* ... */ }
  // ... put, delete
}

class MemoryCache implements ICache {
  constructor(
    private maxSize: number,
    private httpClient: IHttpClient,  // Fallback to API if cache miss
    private logger: ILogger
  ) {}

  private cache = new Map<string, { value: any, expires: number }>()

  async get(key: string) {
    const item = this.cache.get(key)
    if (item && item.expires > Date.now()) {
      this.logger.log(`Cache HIT: ${key}`)
      return item.value
    }
    this.logger.log(`Cache MISS: ${key}`)
    return null
  }

  async set(key: string, value: any, ttl: number = 3600) {
    this.cache.set(key, { value, expires: Date.now() + ttl * 1000 })
  }
}

class EmailService implements IEmailService {
  constructor(
    private config: EmailConfig,
    private logger: ILogger
  ) {}

  async sendEmail(to: string, subject: string, body: string) {
    this.logger.log(`Sending email to ${to}`)
    // ... SMTP logic
  }
}

class UserApi implements IUserApi {
  constructor(
    private httpClient: IHttpClient,
    private logger: ILogger
  ) {}

  async getUser(id: string): Promise<User> {
    this.logger.log(`Fetching user ${id} from API`)
    return this.httpClient.get<User>(`/users/${id}`)
  }

  async createUser(data: CreateUserDto): Promise<User> {
    this.logger.log(`Creating user ${data.email}`)
    return this.httpClient.post<User>('/users', data)
  }
}

class UserRepository implements IUserRepository {
  constructor(
    private userApi: IUserApi,
    private cache: ICache,
    private logger: ILogger
  ) {}

  async findById(id: string): Promise<User> {
    // Try cache first
    const cached = await this.cache.get(`user:${id}`)
    if (cached) return cached

    // Fallback to API
    const user = await this.userApi.getUser(id)
    await this.cache.set(`user:${id}`, user, 3600)
    return user
  }

  async save(user: User): Promise<void> {
    await this.userApi.createUser(user)
    await this.cache.set(`user:${user.id}`, user, 3600)
  }
}

class UserService implements IUserService {
  constructor(
    private userRepo: IUserRepository,
    private emailService: IEmailService,
    private logger: ILogger
  ) {}

  async getUser(id: string): Promise<User> {
    this.logger.log(`Fetching user ${id}`)
    return this.userRepo.findById(id)
  }

  async createUser(email: string, name: string): Promise<User> {
    this.logger.log(`Creating user ${email}`)
    const user = await this.userRepo.save({ email, name })
    await this.emailService.sendEmail(email, 'Welcome!', `Hello ${name}`)
    return user
  }
}</code></pre>

        <h3 style="margin-top: 32px;">Step 3: Configure DI (ONE Place, ONE Time)</h3>
        <pre class="line-numbers"><code class="language-typescript">// composition-root.ts - ALL configuration in ONE place
import { Container } from '@novadi/core'

const container = new Container()
const builder = container.builder()

// Configuration values (from environment variables)
const httpConfig = {
  baseUrl: process.env.API_BASE_URL || 'https://api.example.com',
  apiKey: process.env.API_KEY,
  timeout: 5000,
  retries: 3
}

const emailConfig = {
  smtp: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT),
  user: process.env.SMTP_USER,
  password: process.env.SMTP_PASSWORD
}

const cacheMaxSize = 1000

// Register infrastructure (singletons - created once)
builder.registerInstance(httpConfig).as<HttpConfig>()
builder.registerInstance(emailConfig).as<EmailConfig>()
builder.registerInstance(cacheMaxSize).as('maxSize')

builder.registerType(ConsoleLogger)
  .as<ILogger>()
  .singleInstance()

builder.registerType(FetchHttpClient)
  .as<IHttpClient>()
  .autoWire()  // ‚ú® Automatically wires: config, logger
  .singleInstance()

builder.registerType(MemoryCache)
  .as<ICache>()
  .autoWire()  // ‚ú® Automatically wires: maxSize, httpClient, logger
  .singleInstance()

builder.registerType(EmailService)
  .as<IEmailService>()
  .autoWire()  // ‚ú® Automatically wires: config, logger
  .singleInstance()

// Register API layer
builder.registerType(UserApi)
  .as<IUserApi>()
  .autoWire()  // ‚ú® Automatically wires: httpClient, logger
  .singleInstance()

// Register domain services
builder.registerType(UserRepository)
  .as<IUserRepository>()
  .autoWire()  // ‚ú® Automatically wires: userApi, cache, logger
  .instancePerRequest()

builder.registerType(UserService)
  .as<IUserService>()
  .autoWire()  // ‚ú® Automatically wires: userRepo, emailService, logger
  .instancePerRequest()

export const app = builder.build()</code></pre>

        <h3 style="margin-top: 32px;">Step 4: Use It - Simple and Clean</h3>
        <pre class="line-numbers"><code class="language-typescript">// In your application code
import { app } from './composition-root'

// Resolve the entire object graph with ONE line
const userService = app.resolveType<IUserService>()

// Everything is wired automatically:
// ‚úÖ UserService gets UserRepository, EmailService, Logger
// ‚úÖ UserRepository gets UserApi, MemoryCache, Logger
// ‚úÖ UserApi gets FetchHttpClient, Logger
// ‚úÖ MemoryCache gets maxSize, FetchHttpClient, Logger
// ‚úÖ FetchHttpClient gets HttpConfig, Logger
// ‚úÖ EmailService gets EmailConfig, Logger
// ‚úÖ Logger is shared (singleton) across everything

// Use it
const user = await userService.getUser('123')
console.log(user)

const newUser = await userService.createUser('jane@example.com', 'Jane Doe')
console.log(newUser)</code></pre>
      </div>

      <div class="info-box info-box-tip">
        <h5 class="info-box-title">üéØ Key Takeaways</h5>
        <ul style="margin: 12px 0 0 20px; color: var(--text-secondary);">
          <li><strong>Configuration in ONE place:</strong> All API keys, secrets, and wiring in composition root</li>
          <li><strong>Clean domain code:</strong> No framework knowledge in your business logic</li>
          <li><strong>Convention over configuration:</strong> <code>.autoWire()</code> handles wiring automatically</li>
          <li><strong>Easy testing:</strong> Pass mock implementations to constructors</li>
          <li><strong>Flexible lifetimes:</strong> Singletons for infrastructure (HTTP client, cache), per-request for domain services</li>
          <li><strong>Type-safe:</strong> TypeScript catches errors at compile time</li>
        </ul>
      </div>
    </section>

    <!-- Testing -->
    <section class="section">
      <h2>Testing Made Trivial</h2>
      <p>
        With DI, testing is as simple as passing mock implementations. No need for complex mocking frameworks
        or to worry about hitting real API endpoints.
      </p>

      <div class="card">
        <pre class="line-numbers"><code class="language-typescript">// test/user-service.test.ts
import { UserService } from '../src/services/user-service'

// Create simple mocks - no HTTP calls, no API endpoints
const mockLogger: ILogger = {
  log: jest.fn(),
  error: jest.fn()
}

const mockEmailService: IEmailService = {
  sendEmail: jest.fn().mockResolvedValue(undefined)
}

const mockUserRepo: IUserRepository = {
  findById: jest.fn().mockResolvedValue({ id: '123', name: 'John' }),
  save: jest.fn().mockResolvedValue({ id: '456', name: 'Jane' })
}

// Test without ANY infrastructure (no HTTP, no cache, no real APIs)
test('getUser returns user from repository', async () => {
  const service = new UserService(mockUserRepo, mockEmailService, mockLogger)

  const user = await service.getUser('123')

  expect(user).toEqual({ id: '123', name: 'John' })
  expect(mockUserRepo.findById).toHaveBeenCalledWith('123')
  expect(mockLogger.log).toHaveBeenCalledWith('Fetching user 123')
})

test('createUser sends welcome email', async () => {
  const service = new UserService(mockUserRepo, mockEmailService, mockLogger)

  await service.createUser('jane@example.com', 'Jane')

  expect(mockEmailService.sendEmail).toHaveBeenCalledWith(
    'jane@example.com',
    'Welcome!',
    'Hello Jane'
  )
})

// You can also test the UserRepository layer if needed
test('UserRepository uses cache and falls back to API', async () => {
  const mockHttpClient: IHttpClient = {
    get: jest.fn().mockResolvedValue({ id: '123', name: 'John' }),
    post: jest.fn(),
    put: jest.fn(),
    delete: jest.fn()
  }

  const mockCache: ICache = {
    get: jest.fn().mockResolvedValue(null), // Cache miss
    set: jest.fn()
  }

  const mockUserApi: IUserApi = {
    getUser: jest.fn().mockResolvedValue({ id: '123', name: 'John' }),
    createUser: jest.fn()
  }

  const repo = new UserRepository(mockUserApi, mockCache, mockLogger)
  const user = await repo.findById('123')

  // Verify cache was checked first
  expect(mockCache.get).toHaveBeenCalledWith('user:123')
  // Verify API was called on cache miss
  expect(mockUserApi.getUser).toHaveBeenCalledWith('123')
  // Verify result was cached
  expect(mockCache.set).toHaveBeenCalledWith('user:123', user, 3600)
})</code></pre>
      </div>
    </section>

    <!-- Conclusion -->
    <section class="section">
      <div class="card" style="text-align: center; padding: 48px 32px; background: linear-gradient(135deg, var(--surface) 0%, var(--bg-secondary) 100%);">
        <h2 style="margin-top: 0;">Ready to Build Better Applications?</h2>
        <p class="text-secondary" style="margin-bottom: 32px; font-size: 18px;">
          Stop fighting with manual instantiation and start using proper dependency injection
        </p>
        <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
          <a href="getting-started.html" class="btn btn-primary btn-lg">Get Started with NovaDI</a>
          <a href="guide.html" class="btn btn-secondary btn-lg">Read Complete Documentation</a>
        </div>
      </div>
    </section>

  </div>

  </main>

  <!-- Footer -->
  <footer class="main-footer">
    <div class="container">
      <p>
        <a href="https://github.com/janus007/NovaDI">View on GitHub</a> ‚Ä¢
        <a href="https://www.npmjs.com/package/@novadi/core">npm</a> ‚Ä¢
        <a href="https://github.com/janus007/NovaDI/issues">Report Issue</a>
      </p>
      <p class="text-secondary">Built with ‚ù§Ô∏è for TypeScript developers</p>
    </div>
  </footer>

  <!-- Prism.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

  <!-- Docs JavaScript -->
  <script src="js/docs.js"></script>

</body>
</html>
