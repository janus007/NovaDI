<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Reference - NovaDI</title>
    <meta name="description" content="Complete API reference for NovaDI dependency injection framework.">

    <!-- Theme Init -->
    <script>
      (function() {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const savedTheme = localStorage.getItem('theme');
        const theme = savedTheme || (prefersDark ? 'dark' : 'light');
        document.documentElement.setAttribute('data-theme', theme);
      })();
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Roboto+Slab:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=optional" rel="stylesheet">

    <link rel="stylesheet" href="css/docs.css">

    <!-- Prism.js -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
  </head>
  <body>
    <!-- Mobile Menu Button -->
    <button class="mobile-menu-button" aria-label="Toggle navigation menu">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>

    <div class="mobile-menu-backdrop"></div>

    <!-- Header -->
    <header class="main-header">
      <a href="index.html" class="header-logo">NovaDI</a>
      <div class="header-links">
        <a href="https://www.npmjs.com/package/@novadi/core" target="_blank" rel="noopener noreferrer">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M0 7.334v8h6.666v1.332H12v-1.332h12v-8H0zm6.666 6.664H5.334v-4H3.999v4H1.335V8.667h5.331v5.331zm4 0v1.336H8.001V8.667h5.334v5.332h-2.669v-.001zm12.001 0h-1.33v-4h-1.336v4h-1.335v-4h-1.33v4h-2.671V8.667h8.002v5.331zM10.665 10H12v2.667h-1.335V10z"></path></svg>
          npm
        </a>
        <a href="https://github.com/janus007/NovaDI" target="_blank" rel="noopener noreferrer">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>
          GitHub
        </a>
        <button type="submit" id="theme-toggle" aria-label="Toggle theme">
          <span class="theme-icon">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z"></path></svg>
          </span>
        </button>
      </div>
    </header>

    <!-- Sidebar -->
    <aside class="main-nav">
      <div class="nav-container">
        <div class="api-search-container">
          <input type="text" class="api-search" placeholder="Search API..." aria-label="Search API">
          <svg class="api-search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"></circle>
            <path d="m21 21-4.35-4.35"></path>
          </svg>
        </div>

        <ul class="nav-links">
          <li class="nav-group">
            <div class="nav-group-title">Documentation</div>
            <a href="getting-started.html">Getting Started</a>
            <a href="guide.html">Documentation</a>
            <a href="api-reference.html" class="active">API Reference</a>
          </li>
          <li class="nav-group">
            <div class="nav-group-title">Container</div>
            <a href="#container">Overview</a>
            <a href="#resolveType" class="nav-sub-link">resolveType&lt;T&gt;()</a>
          </li>
          <li class="nav-group">
            <div class="nav-group-title">Builder</div>
            <a href="#builder">Overview</a>
            <a href="#registerType" class="nav-sub-link">registerType&lt;T&gt;()</a>
          </li>
          <li class="nav-group">
            <div class="nav-group-title">AutoWire</div>
            <a href="#autowire">Overview</a>
            <a href="#autoWire" class="nav-sub-link">autoWire()</a>
            <a href="#autowire-options" class="nav-sub-link">AutoWireOptions</a>
            <a href="#advanced-techniques" class="nav-sub-link">Advanced Techniques</a>
          </li>
          <li class="nav-group">
            <div class="nav-group-title">Reference</div>
            <a href="#api-overview">API Overview</a>
            <a href="#errors">Error Classes</a>
            <a href="#binding-not-found" class="nav-sub-link">BindingNotFoundError</a>
            <a href="#circular" class="nav-sub-link">CircularDependencyError</a>
          </li>
        </ul>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <div class="hero">
        <div class="container">
          <h1 class="hero-title">API Reference</h1>
          <p class="hero-subtitle">Complete reference for all NovaDI APIs with real-world examples</p>
        </div>
      </div>

      <div class="container py-section">

        <!-- ==================== CONTAINER ==================== -->
        <section class="api-section" id="container">
          <h2>Container</h2>
          <p class="text-secondary mb-32">The core dependency injection container that manages service registration and resolution with support for multiple lifetimes, circular dependency detection, and automatic disposal.</p>

          <!-- resolveType<T>() -->
          <div class="api-method-card" id="resolveType">
            <div class="api-method-header" data-expandable>
              <div class="api-method-title-row">
                <h3 class="api-method-name">resolveType<span class="api-method-generic">&lt;T&gt;</span></h3>
                <button class="api-expand-btn" aria-label="Toggle method details">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
              </div>
              <div class="api-method-signature">
                <code>container.resolveType&lt;T&gt;(typeName?: string): T</code>
              </div>
              <p class="api-method-summary">Resolves a service by its interface type name. Type name is automatically injected by the transformer at compile-time for zero-runtime overhead.</p>
            </div>

            <div class="api-method-body">
              <h4 class="api-section-title">How It Works</h4>
              <p>The NovaDI transformer scans your code and automatically injects the interface type name as a string literal at build time. This provides type-safe resolution without runtime reflection or decorators.</p>

              <div class="info-box info-box-info mt-16">
                <h4 class="info-box-title">Transformer Magic</h4>
                <p><strong>You write:</strong> <code>container.resolveType&lt;ILogger&gt;()</code></p>
                <p><strong>Transformer generates:</strong> <code>container.resolveType&lt;ILogger&gt;('ILogger')</code></p>
                <p>The type name is injected at compile-time, giving you both type safety and zero runtime overhead.</p>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Parameters</h4>
                <table class="api-params-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <code>typeName</code>
                        <span class="api-badge api-badge-optional">Optional</span>
                      </td>
                      <td><code class="api-type">string</code></td>
                      <td>The interface type name (automatically injected by transformer)</td>
                    </tr>
                  </tbody>
                </table>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Returns</h4>
                <div class="api-return-block">
                  <code class="api-type">T</code>
                  <p>The resolved service instance with full TypeScript type inference</p>
                </div>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Real-World Example</h4>
                <div class="api-code-block">
                  <button class="api-copy-btn" aria-label="Copy code">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span>Copy</span>
                  </button>
                  <pre><code class="language-typescript">// Service interfaces
interface IEventBus {
  publish(event: string, data: any): void
}

interface ILogger {
  log(message: string): void
}

class EventBus implements IEventBus {
  constructor(private logger: ILogger) {}

  publish(event: string, data: any) {
    this.logger.log(`Event: ${event}`)
    // Publish logic...
  }
}

// Register with automatic transformer-based resolution
const container = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;().singleInstance()
  .registerType(EventBus).as&lt;IEventBus&gt;().singleInstance()
  .build()

// ✨ Clean resolution with transformer magic
const eventBus = container.resolveType&lt;IEventBus&gt;()
// Transformer auto-injects: container.resolveType&lt;IEventBus&gt;('IEventBus')

eventBus.publish('user.login', { userId: 123 })</code></pre>
                </div>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Use Cases</h4>
                <ul>
                  <li><strong>Clean resolution</strong>: No explicit Token creation needed</li>
                  <li><strong>Type-safe</strong>: Full TypeScript inference without decorators</li>
                  <li><strong>Minification-safe</strong>: String literals injected at build time, not runtime</li>
                  <li><strong>Refactoring-friendly</strong>: Rename interface → transformer updates everywhere</li>
                </ul>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">See Also</h4>
                <ul class="api-see-also">
                  <li><a href="#resolve">resolve&lt;T&gt;()</a></li>
                  <li><a href="#resolveTypeAll">resolveTypeAll&lt;T&gt;()</a></li>
                </ul>
              </div>
            </div>
          </div>

        </section>

        <hr>

        <!-- ==================== BUILDER ==================== -->
        <section class="api-section" id="builder">
          <h2>Builder</h2>
          <p class="text-secondary mb-32">Fluent API for configuring the container with Autofac-style syntax. Provides a clean, chainable interface for registering services.</p>

          <!-- registerType<T>() -->
          <div class="api-method-card" id="registerType">
            <div class="api-method-header" data-expandable>
              <div class="api-method-title-row">
                <h3 class="api-method-name">registerType<span class="api-method-generic">&lt;T&gt;</span></h3>
                <button class="api-expand-btn" aria-label="Toggle method details">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
              </div>
              <div class="api-method-signature">
                <code>builder.registerType&lt;T&gt;(constructor: new (...args: any[]) => T): RegistrationBuilder&lt;T&gt;</code>
              </div>
              <p class="api-method-summary">Register a class constructor for dependency injection with automatic autowiring powered by the build-time transformer.</p>
            </div>

            <div class="api-method-body">
              <h4 class="api-section-title">How It Works</h4>
              <p>When you register a class with <code>registerType</code>, the NovaDI transformer analyzes its constructor parameters at build time and automatically generates resolver functions for each typed dependency. This provides automatic dependency injection without decorators or reflection.</p>

              <div class="api-section-block">
                <h4 class="api-section-title">Parameters</h4>
                <table class="api-params-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <code>constructor</code>
                        <span class="api-badge api-badge-required">Required</span>
                      </td>
                      <td><code class="api-type">new (...args: any[]) => T</code></td>
                      <td>The class constructor to register</td>
                    </tr>
                  </tbody>
                </table>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Returns</h4>
                <div class="api-return-block">
                  <code class="api-type">RegistrationBuilder&lt;T&gt;</code>
                  <p>A fluent builder for configuring the registration (lifetime, binding, etc.)</p>
                </div>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Real-World Example</h4>
                <div class="api-code-block">
                  <button class="api-copy-btn" aria-label="Copy code">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span>Copy</span>
                  </button>
                  <pre><code class="language-typescript">// Service classes
class UserRepository {
  constructor(
    private database: IDatabase,
    private logger: ILogger
  ) {}

  async findById(id: number) {
    this.logger.log(`Finding user ${id}`)
    return this.database.query('SELECT * FROM users WHERE id = ?', [id])
  }
}

class UserService {
  constructor(
    private repository: UserRepository,
    private eventBus: IEventBus
  ) {}

  async getUser(id: number) {
    const user = await this.repository.findById(id)
    this.eventBus.publish('user.fetched', { id })
    return user
  }
}

// Register with automatic autowiring
const container = new Builder()
  .registerType(Database).as&lt;IDatabase&gt;().singleInstance()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;().singleInstance()
  .registerType(EventBus).as&lt;IEventBus&gt;().singleInstance()
  .registerType(UserRepository).singleInstance()  // ✨ Auto-wires database + logger
  .registerType(UserService).singleInstance()     // ✨ Auto-wires repository + eventBus
  .build()

// Everything is wired automatically!
const userService = container.resolveType&lt;UserService&gt;()
const user = await userService.getUser(123)</code></pre>
                </div>
              </div>

              <div class="info-box info-box-tip mt-16">
                <h4 class="info-box-title">Automatic Autowiring</h4>
                <p>The transformer analyzes constructor parameters and generates <code>mapResolvers</code> arrays at build time. This provides O(1) array access performance and is minification-safe. You don't need to call <code>.autoWire()</code> explicitly unless you have primitives that need manual mapping.</p>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Chain Methods</h4>
                <div class="api-chain-methods">
                  <a href="#as" class="api-chain-link">
                    <code>.as&lt;T&gt;()</code>
                    <span>Bind to interface type</span>
                  </a>
                  <a href="#singleInstance" class="api-chain-link">
                    <code>.singleInstance()</code>
                    <span>Singleton lifetime</span>
                  </a>
                  <a href="#instancePerRequest" class="api-chain-link">
                    <code>.instancePerRequest()</code>
                    <span>Per-request scope</span>
                  </a>
                  <a href="#autoWire" class="api-chain-link">
                    <code>.autoWire()</code>
                    <span>Configure autowiring</span>
                  </a>
                  <a href="#withParameters" class="api-chain-link">
                    <code>.withParameters()</code>
                    <span>Inject primitives</span>
                  </a>
                </div>
              </div>
            </div>
          </div>

        </section>


        <hr>

        <!-- ==================== AUTOWIRE ==================== -->
        <section class="api-section" id="autowire">
          <h2>AutoWire</h2>
          <p class="text-secondary mb-32">Automatic dependency injection strategies. The transformer generates optimal resolution code at build time for zero runtime overhead.</p>

          <!-- autowire() -->
          <div class="api-method-card" id="autoWire">
            <div class="api-method-header" data-expandable>
              <div class="api-method-title-row">
                <h3 class="api-method-name">autoWire<span class="api-method-generic">()</span></h3>
                <button class="api-expand-btn" aria-label="Toggle method details">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
              </div>
              <div class="api-method-signature">
                <code>builder.autoWire(options?: AutoWireOptions): this</code>
              </div>
              <p class="api-method-summary">Configure automatic dependency injection for constructor parameters. Supports two strategies: mapResolvers (transformer-generated, optimal) and map (manual overrides).</p>
            </div>

            <div class="api-method-body">
              <h4 class="api-section-title">How It Works</h4>
              <p>AutoWire has two strategies with automatic fallback:</p>
              <ol>
                <li><strong>mapResolvers</strong> (Primary): Transformer-generated array with O(1) access per parameter</li>
                <li><strong>map</strong> (Fallback): Manual object mapping for edge cases (primitives, environment variables)</li>
              </ol>

              <div class="info-box info-box-tip mt-16">
                <h4 class="info-box-title">When Do You Need .autoWire()?</h4>
                <p><strong>You don't need it for typed dependencies!</strong> The transformer automatically generates <code>mapResolvers</code> for all interface/class types.</p>
                <p><strong>You only need it for:</strong></p>
                <ul class="ml-20 mt-8">
                  <li>Primitive constructor parameters (strings, numbers, booleans)</li>
                  <li>Environment variables and configuration values</li>
                  <li>External constants that aren't DI services</li>
                </ul>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Real-World Example: Mixing Primitives + DI</h4>
                <div class="api-code-block">
                  <button class="api-copy-btn" aria-label="Copy code">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span>Copy</span>
                  </button>
                  <pre><code class="language-typescript">class ApiClient implements IHttpClient {
  constructor(
    private baseUrl: string,        // ⚠️ Primitive - needs manual mapping
    private apiKey: string,         // ⚠️ Primitive - needs manual mapping
    private logger: ILogger,        // ✅ Typed - transformer handles this
    private retryCount: number      // ⚠️ Primitive - needs manual mapping
  ) {}

  async get&lt;T&gt;(endpoint: string): Promise&lt;T&gt; {
    this.logger.log(`GET ${this.baseUrl}${endpoint}`)
    // HTTP logic...
  }
}

// Register with mixed autowiring
const container = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;().singleInstance()
  .registerType(ApiClient).as&lt;IHttpClient&gt;().autoWire({
    map: {
      baseUrl: () => import.meta.env.VITE_API_BASE_URL,
      apiKey: () => import.meta.env.VITE_API_KEY,
      // logger: Transformer already handles this! ✨
      retryCount: () => 3
    }
  }).singleInstance()
  .build()

const client = container.resolveType&lt;IHttpClient&gt;()
await client.get('/users')</code></pre>
                </div>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Performance Comparison</h4>
                <table class="api-params-table">
                  <thead>
                    <tr>
                      <th>Strategy</th>
                      <th>Performance</th>
                      <th>Minification-Safe</th>
                      <th>When to Use</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td><code>mapResolvers</code></td>
                      <td>⚡ O(1) array access</td>
                      <td>✅ Yes</td>
                      <td>Automatic (transformer-generated)</td>
                    </tr>
                    <tr>
                      <td><code>map</code></td>
                      <td>🔍 Object property lookup</td>
                      <td>⚠️ Depends on minifier</td>
                      <td>Primitives & config values</td>
                    </tr>
                  </tbody>
                </table>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Use Cases</h4>
                <ul>
                  <li><strong>Environment variables</strong>: API keys, URLs, feature flags from process.env</li>
                  <li><strong>Configuration objects</strong>: Port numbers, timeouts, retry counts</li>
                  <li><strong>External constants</strong>: Build-time values, version strings</li>
                  <li><strong>Testing mocks</strong>: Override specific dependencies for unit tests</li>
                  <li><strong>Polymorphism</strong>: Explicit interface selection when conventions don't match</li>
                  <li><strong>Nested interfaces</strong>: Specific implementations of base interfaces</li>
                </ul>
              </div>

              <div class="api-section-block">
                <h4 class="api-section-title">Advanced: Explicit Interface Mapping with .map</h4>
                <p>Sometimes the transformer needs help resolving the correct interface, especially with polymorphism and nested interface hierarchies. Use the <code>map</code> option to explicitly specify which implementation to inject.</p>

                <div class="info-box info-box-warning mt-16">
                  <h4 class="info-box-title">When Naming Conventions Don't Match</h4>
                  <p>If your class name doesn't follow the "remove I from interface" convention, the transformer might not find the right registration. Use explicit mapping to tell it exactly which interface to resolve.</p>
                </div>

                <div class="api-code-block mt-16">
                  <button class="api-copy-btn" aria-label="Copy code">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span>Copy</span>
                  </button>
                  <pre><code class="language-typescript">// Example 1: Naming convention mismatch
interface IPaymentProcessor {
  processPayment(amount: number): Promise&lt;void&gt;
}

interface INotificationService {
  notify(message: string): void
}

// ❌ Class name doesn't match IPaymentProcessor convention
class StripePaymentGateway implements IPaymentProcessor {
  constructor(private notificationService: INotificationService) {}

  async processPayment(amount: number) {
    // Process with Stripe...
    this.notificationService.notify(`Processed $${amount}`)
  }
}

// ✅ Explicit mapping tells transformer which interface to use
const container = new Builder()
  .registerType(EmailNotificationService).as&lt;INotificationService&gt;().singleInstance()
  .registerType(StripePaymentGateway)
    .as&lt;IPaymentProcessor&gt;()
    .autoWire({
      map: {
        // Explicitly resolve INotificationService (transformer can't infer from parameter name)
        notificationService: (c) => c.resolveType&lt;INotificationService&gt;()
      }
    })
    .singleInstance()
  .build()</code></pre>
                </div>

                <h4 class="api-section-title mt-32">Polymorphism: Selecting Specific Implementations</h4>
                <p>When working with interface hierarchies (e.g., <code>IMonkey implements IAnimal</code>), you often want to inject a <strong>specific implementation</strong> rather than just any <code>IAnimal</code>. This is common in polymorphic designs.</p>

                <div class="api-code-block mt-16">
                  <button class="api-copy-btn" aria-label="Copy code">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span>Copy</span>
                  </button>
                  <pre><code class="language-typescript">// Interface hierarchy
interface IAnimal {
  makeSound(): string
}

interface IMonkey extends IAnimal {
  climb(): void
}

interface IElephant extends IAnimal {
  trumpet(): void
}

// Implementations
class Monkey implements IMonkey {
  makeSound() { return 'Ooh ooh ah ah!' }
  climb() { console.log('🌴 Climbing tree...') }
}

class Elephant implements IElephant {
  makeSound() { return 'Paaooo!' }
  trumpet() { console.log('🎺 Trumpeting...') }
}

// Zoo needs a SPECIFIC animal, not just any IAnimal
class MonkeyZoo {
  constructor(
    private animal: IAnimal  // ⚠️ Parameter type is IAnimal, but we want IMonkey specifically!
  ) {}

  performShow() {
    console.log(this.animal.makeSound())
    // We know it's a monkey, so we want to call climb()
    if ('climb' in this.animal) {
      (this.animal as IMonkey).climb()
    }
  }
}

// ✅ Explicit mapping: Inject IMonkey even though parameter type is IAnimal
const container = new Builder()
  .registerType(Monkey).as&lt;IMonkey&gt;().singleInstance()
  .registerType(Elephant).as&lt;IElephant&gt;().singleInstance()
  .registerType(MonkeyZoo)
    .autoWire({
      map: {
        // Explicitly resolve IMonkey, not generic IAnimal
        animal: (c) => c.resolveType&lt;IMonkey&gt;()
      }
    })
    .singleInstance()
  .build()

const zoo = container.resolveType&lt;MonkeyZoo&gt;()
zoo.performShow()  // 🐵 "Ooh ooh ah ah!" + climbing</code></pre>
                </div>

                <div class="info-box info-box-tip mt-16">
                  <h4 class="info-box-title">Why Not Just Use IMonkey as Parameter Type?</h4>
                  <p><strong>Design flexibility!</strong> Sometimes you want the class to accept any <code>IAnimal</code> for flexibility, but configure it with a specific implementation at registration time. This is the <strong>Strategy Pattern</strong> in action.</p>
                  <p>Other times, the parameter type is defined in a third-party library you can't change, so explicit mapping is your only option.</p>
                </div>

                <h4 class="api-section-title mt-32">Multiple Registrations: Choosing Between Implementations</h4>
                <p>When you have multiple implementations of the same interface, use <code>map</code> to explicitly select which one to inject.</p>

                <div class="api-code-block mt-16">
                  <button class="api-copy-btn" aria-label="Copy code">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span>Copy</span>
                  </button>
                  <pre><code class="language-typescript">interface ILogger {
  log(message: string): void
}

class ConsoleLogger implements ILogger {
  log(msg: string) { console.log(msg) }
}

class FileLogger implements ILogger {
  log(msg: string) { /* write to file */ }
}

class CloudLogger implements ILogger {
  log(msg: string) { /* send to cloud */ }
}

// Service needs TWO different loggers for different purposes
class PaymentService {
  constructor(
    private auditLogger: ILogger,      // Should be FileLogger for compliance
    private debugLogger: ILogger       // Should be ConsoleLogger for dev
  ) {}
}

// ✅ Explicit mapping: Different ILogger implementations for different parameters
const container = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;().named('console').singleInstance()
  .registerType(FileLogger).as&lt;ILogger&gt;().named('file').singleInstance()
  .registerType(PaymentService)
    .autoWire({
      map: {
        auditLogger: (c) => c.resolveTypeNamed&lt;ILogger&gt;('file'),
        debugLogger: (c) => c.resolveTypeNamed&lt;ILogger&gt;('console')
      }
    })
    .singleInstance()
  .build()</code></pre>
                </div>
              </div>
            </div>
          </div>

          <!-- AutoWireOptions Interface -->
          <div class="api-method-card" id="autowire-options">
            <div class="api-method-header" data-expandable>
              <div class="api-method-title-row">
                <h3 class="api-method-name">AutoWireOptions</h3>
                <span class="api-badge api-badge-static">Interface</span>
                <button class="api-expand-btn" aria-label="Toggle method details">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
              </div>
              <div class="api-method-signature">
                <code>interface AutoWireOptions</code>
              </div>
              <p class="api-method-summary">Configuration options for automatic dependency injection behavior.</p>
            </div>

            <div class="api-method-body">
              <h4 class="api-section-title">Properties</h4>
              <table class="api-params-table">
                <thead>
                  <tr>
                    <th>Property</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <code>strict</code>
                      <span class="api-badge api-badge-optional">Optional</span>
                    </td>
                    <td><code class="api-type">boolean</code></td>
                    <td>Enable strict mode: throw error if dependency cannot be resolved. Default: <code>false</code></td>
                  </tr>
                  <tr>
                    <td>
                      <code>map</code>
                      <span class="api-badge api-badge-optional">Optional</span>
                    </td>
                    <td><code class="api-type">Record&lt;string, (c: Container) => any&gt;</code></td>
                    <td>Manual mapping object with parameter names as keys and resolver functions as values. Used for primitives, environment variables, and explicit interface selection.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>mapResolvers</code>
                      <span class="api-badge api-badge-optional">Optional</span>
                    </td>
                    <td><code class="api-type">Array&lt;((c: Container) => any) | undefined&gt;</code></td>
                    <td>Array of resolver functions in parameter position order. Automatically generated by the transformer for optimal performance (O(1) array access).</td>
                  </tr>
                  <tr>
                    <td>
                      <code>by</code>
                      <span class="api-badge api-badge-optional">Optional</span>
                    </td>
                    <td><code class="api-type">'name' | 'type'</code></td>
                    <td>Resolution strategy: <code>'name'</code> for parameter name matching, <code>'type'</code> for type-based resolution (default). Transformer uses type-based resolution for reliability.</td>
                  </tr>
                </tbody>
              </table>

              <div class="api-section-block">
                <h4 class="api-section-title">Example: Combining All Options</h4>
                <div class="api-code-block">
                  <button class="api-copy-btn" aria-label="Copy code">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span>Copy</span>
                  </button>
                  <pre><code class="language-typescript">class DatabaseService {
  constructor(
    private connectionString: string,
    private logger: ILogger,
    private maxRetries: number
  ) {}
}

const container = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;().singleInstance()
  .registerType(DatabaseService)
    .autoWire({
      strict: true,  // Throw error if logger is not registered
      map: {
        connectionString: () => process.env.DB_CONNECTION_STRING,
        maxRetries: () => 3
        // logger is handled by transformer automatically via mapResolvers
      },
      by: 'type'  // Use type-based resolution (default)
    })
    .singleInstance()
  .build()</code></pre>
                </div>
              </div>
            </div>
          </div>

          <!-- Advanced Techniques -->
          <div class="api-method-card" id="advanced-techniques">
            <div class="api-method-header" data-expandable>
              <div class="api-method-title-row">
                <h3 class="api-method-name">Advanced Techniques</h3>
                <button class="api-expand-btn" aria-label="Toggle method details">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
              </div>
              <p class="api-method-summary">Advanced autowiring patterns for complex scenarios: factory resolution, conditional injection, scope-aware dependencies, and dynamic configuration.</p>
            </div>

            <div class="api-method-body">

              <h4 class="api-section-title">1. Factory-Based Resolution</h4>
              <p>Use factory functions in <code>map</code> to create complex dependencies or add custom logic during resolution.</p>

              <div class="api-code-block">
                <button class="api-copy-btn" aria-label="Copy code">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  <span>Copy</span>
                </button>
                <pre><code class="language-typescript">// Complex configuration object factory
interface IConfig {
  apiUrl: string
  timeout: number
  retryStrategy: 'exponential' | 'linear'
}

class ApiService {
  constructor(
    private config: IConfig,
    private logger: ILogger
  ) {}
}

const container = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;().singleInstance()
  .registerType(ApiService)
    .autoWire({
      map: {
        // Factory creates config based on environment
        config: () => ({
          apiUrl: import.meta.env.PROD
            ? 'https://api.production.com'
            : 'http://localhost:3000',
          timeout: import.meta.env.PROD ? 10000 : 30000,
          retryStrategy: import.meta.env.PROD ? 'exponential' : 'linear'
        })
      }
    })
    .singleInstance()
  .build()</code></pre>
              </div>

              <h4 class="api-section-title mt-32">2. Conditional Injection Based on Environment</h4>
              <p>Inject different implementations based on runtime conditions like environment, feature flags, or configuration.</p>

              <div class="api-code-block">
                <button class="api-copy-btn" aria-label="Copy code">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  <span>Copy</span>
                </button>
                <pre><code class="language-typescript">interface ICache {
  get(key: string): Promise&lt;any&gt;
  set(key: string, value: any): Promise&lt;void&gt;
}

class RedisCache implements ICache {
  async get(key: string) { /* Redis implementation */ }
  async set(key: string, value: any) { /* Redis implementation */ }
}

class InMemoryCache implements ICache {
  async get(key: string) { /* In-memory implementation */ }
  async set(key: string, value: any) { /* In-memory implementation */ }
}

class UserService {
  constructor(private cache: ICache) {}
}

const container = new Builder()
  .registerType(RedisCache).as&lt;ICache&gt;().named('redis').singleInstance()
  .registerType(InMemoryCache).as&lt;ICache&gt;().named('memory').singleInstance()
  .registerType(UserService)
    .autoWire({
      map: {
        // Conditional: Use Redis in production, in-memory for dev/test
        cache: (c) => {
          const env = import.meta.env.MODE
          return env === 'production'
            ? c.resolveTypeNamed&lt;ICache&gt;('redis')
            : c.resolveTypeNamed&lt;ICache&gt;('memory')
        }
      }
    })
    .singleInstance()
  .build()</code></pre>
              </div>

              <h4 class="api-section-title mt-32">3. Scope-Aware Dependencies</h4>
              <p>Create child containers and resolve scoped dependencies for request-specific or tenant-specific contexts.</p>

              <div class="api-code-block">
                <button class="api-copy-btn" aria-label="Copy code">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  <span>Copy</span>
                </button>
                <pre><code class="language-typescript">interface IRequestContext {
  userId: string
  tenantId: string
}

class RequestContext implements IRequestContext {
  constructor(
    public userId: string,
    public tenantId: string
  ) {}
}

class TenantDatabase {
  constructor(
    private context: IRequestContext,
    private logger: ILogger
  ) {
    this.logger.log(`DB for tenant: ${context.tenantId}`)
  }

  query(sql: string) {
    // Use context.tenantId to route to correct database
  }
}

// Global container with singletons
const rootContainer = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;().singleInstance()
  .registerType(TenantDatabase).scoped()  // Scoped to child container
  .build()

// Per-request child container
function handleRequest(userId: string, tenantId: string) {
  const requestScope = rootContainer.createChild()

  // Register request-specific context
  requestScope.bindValue(
    { symbol: Symbol('IRequestContext') } as any,
    new RequestContext(userId, tenantId),
    { lifetime: 'scoped' }
  )

  // TenantDatabase gets scoped context + singleton logger
  const db = requestScope.resolveType&lt;TenantDatabase&gt;()
  db.query('SELECT * FROM users')

  requestScope.dispose()  // Clean up scoped instances
}</code></pre>
              </div>

              <h4 class="api-section-title mt-32">4. Lazy Resolution with Factories</h4>
              <p>Defer dependency creation until it's actually needed using factory injection.</p>

              <div class="api-code-block">
                <button class="api-copy-btn" aria-label="Copy code">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  <span>Copy</span>
                </button>
                <pre><code class="language-typescript">interface IHeavyService {
  process(): void
}

class HeavyService implements IHeavyService {
  constructor() {
    console.log('⚠️ Expensive initialization!')
  }
  process() { /* Heavy work */ }
}

// Instead of injecting the service directly, inject a factory
type ServiceFactory&lt;T&gt; = () => T

class OptimizedController {
  constructor(
    private serviceFactory: ServiceFactory&lt;IHeavyService&gt;,
    private logger: ILogger
  ) {}

  handleRequest(needsHeavyProcessing: boolean) {
    this.logger.log('Request received')

    if (needsHeavyProcessing) {
      // Only create HeavyService when actually needed!
      const service = this.serviceFactory()
      service.process()
    }
  }
}

const container = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;()
  .registerType(HeavyService).as&lt;IHeavyService&gt;().instancePerDependency()
  .registerType(OptimizedController)
    .autoWire({
      map: {
        // Inject a factory function instead of the service itself
        serviceFactory: (c) => () => c.resolveType&lt;IHeavyService&gt;()
      }
    })
  .build()

const controller = container.resolveType&lt;OptimizedController&gt;()
controller.handleRequest(false)  // ✅ No heavy initialization!
controller.handleRequest(true)   // ⚠️ Now it initializes</code></pre>
              </div>

              <h4 class="api-section-title mt-32">5. Decorator Pattern with DI</h4>
              <p>Wrap services with decorators while maintaining dependency injection.</p>

              <div class="api-code-block">
                <button class="api-copy-btn" aria-label="Copy code">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  <span>Copy</span>
                </button>
                <pre><code class="language-typescript">interface IDataService {
  getData(id: string): Promise&lt;any&gt;
}

class DataService implements IDataService {
  async getData(id: string) {
    // Fetch from database
    return { id, data: 'raw data' }
  }
}

// Decorator: Adds caching
class CachedDataService implements IDataService {
  private cache = new Map()

  constructor(
    private inner: IDataService,
    private logger: ILogger
  ) {}

  async getData(id: string) {
    if (this.cache.has(id)) {
      this.logger.log(`Cache hit: ${id}`)
      return this.cache.get(id)
    }

    const data = await this.inner.getData(id)
    this.cache.set(id, data)
    return data
  }
}

// Decorator: Adds logging
class LoggedDataService implements IDataService {
  constructor(
    private inner: IDataService,
    private logger: ILogger
  ) {}

  async getData(id: string) {
    this.logger.log(`Getting data: ${id}`)
    const result = await this.inner.getData(id)
    this.logger.log(`Got data: ${id}`)
    return result
  }
}

const container = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;()
  .registerType(DataService).named('core').instancePerDependency()

  // Wrap with caching decorator
  .registerType(CachedDataService)
    .named('cached')
    .autoWire({
      map: {
        inner: (c) => c.resolveTypeNamed&lt;IDataService&gt;('core')
      }
    })
    .instancePerDependency()

  // Wrap cached version with logging decorator
  .registerType(LoggedDataService)
    .as&lt;IDataService&gt;()  // This is the final service
    .autoWire({
      map: {
        inner: (c) => c.resolveTypeNamed&lt;IDataService&gt;('cached')
      }
    })
    .singleInstance()
  .build()

// Resolves: LoggedDataService → CachedDataService → DataService
const service = container.resolveType&lt;IDataService&gt;()
await service.getData('123')  // Logs + caches + fetches</code></pre>
              </div>

              <h4 class="api-section-title mt-32">6. Dynamic Configuration with Feature Flags</h4>
              <p>Enable/disable features dynamically at registration time.</p>

              <div class="api-code-block">
                <button class="api-copy-btn" aria-label="Copy code">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  <span>Copy</span>
                </button>
                <pre><code class="language-typescript">interface IAnalytics {
  track(event: string): void
}

class GoogleAnalytics implements IAnalytics {
  track(event: string) {
    console.log(`📊 GA: ${event}`)
  }
}

class MixpanelAnalytics implements IAnalytics {
  track(event: string) {
    console.log(`📈 Mixpanel: ${event}`)
  }
}

class NoOpAnalytics implements IAnalytics {
  track(event: string) {
    // Do nothing (analytics disabled)
  }
}

// Feature flags from environment
const features = {
  analyticsProvider: import.meta.env.VITE_ANALYTICS_PROVIDER, // 'google' | 'mixpanel' | 'none'
  enablePremiumFeatures: import.meta.env.VITE_PREMIUM_FEATURES === 'true'
}

const container = new Builder()
  .registerType(GoogleAnalytics).named('google').singleInstance()
  .registerType(MixpanelAnalytics).named('mixpanel').singleInstance()
  .registerType(NoOpAnalytics).named('none').singleInstance()

  // Main app gets analytics based on feature flag
  .registerType(App)
    .autoWire({
      map: {
        analytics: (c) => {
          switch (features.analyticsProvider) {
            case 'google': return c.resolveTypeNamed&lt;IAnalytics&gt;('google')
            case 'mixpanel': return c.resolveTypeNamed&lt;IAnalytics&gt;('mixpanel')
            default: return c.resolveTypeNamed&lt;IAnalytics&gt;('none')
          }
        },
        premiumEnabled: () => features.enablePremiumFeatures
      }
    })
    .singleInstance()
  .build()</code></pre>
              </div>

              <div class="info-box info-box-tip mt-32">
                <h4 class="info-box-title">Best Practices</h4>
                <ul>
                  <li><strong>Keep it simple</strong>: Only use advanced techniques when you have a real need</li>
                  <li><strong>Transformer first</strong>: Let the transformer handle typed dependencies automatically</li>
                  <li><strong>Use named registrations</strong>: For multiple implementations of the same interface</li>
                  <li><strong>Factory pattern</strong>: For lazy initialization and dynamic dependencies</li>
                  <li><strong>Decorator pattern</strong>: For cross-cutting concerns (logging, caching, validation)</li>
                  <li><strong>Test your factories</strong>: Complex map functions should have unit tests</li>
                </ul>
              </div>
            </div>
          </div>

        </section>

        <hr>

        <!-- ==================== API OVERVIEW ==================== -->
        <section class="api-section" id="api-overview">
          <h2>API Overview</h2>
          <p class="text-secondary mb-32">Complete overview of all NovaDI public methods. Methods marked with ✅ are transformer-based and recommended for use. Methods marked with ⚠️ are token-based low-level APIs used internally.</p>

          <h3 class="mt-32 mb-16">Container Resolution</h3>
          <table class="api-params-table">
            <thead>
              <tr>
                <th style="width: 40px;"></th>
                <th>Method</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>resolveType&lt;T&gt;(typeName?: string)</code></td>
                <td>Primary resolution method. Transformer injects interface name automatically.</td>
              </tr>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>resolveTypeNamed&lt;T&gt;(name: string, typeName?: string)</code></td>
                <td>Resolve named registration. Transformer-compatible.</td>
              </tr>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>resolveTypeKeyed&lt;T&gt;(key: any, typeName?: string)</code></td>
                <td>Resolve keyed registration. Transformer-compatible.</td>
              </tr>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>resolveTypeAll&lt;T&gt;(typeName?: string)</code></td>
                <td>Resolve all registrations for a type. Transformer-compatible.</td>
              </tr>
              <tr>
                <td><span style="color: #f59e0b; font-size: 1.2em;">⚠️</span></td>
                <td><code>resolve&lt;T&gt;(token: Token&lt;T&gt;)</code></td>
                <td>Low-level resolution with explicit Token. Used internally.</td>
              </tr>
              <tr>
                <td><span style="color: #f59e0b; font-size: 1.2em;">⚠️</span></td>
                <td><code>resolveNamed&lt;T&gt;(token: Token&lt;T&gt;, name: string)</code></td>
                <td>Low-level named resolution with Token.</td>
              </tr>
              <tr>
                <td><span style="color: #f59e0b; font-size: 1.2em;">⚠️</span></td>
                <td><code>resolveKeyed&lt;T&gt;(token: Token&lt;T&gt;, key: any)</code></td>
                <td>Low-level keyed resolution with Token.</td>
              </tr>
              <tr>
                <td><span style="color: #f59e0b; font-size: 1.2em;">⚠️</span></td>
                <td><code>resolveAll&lt;T&gt;(token: Token&lt;T&gt;)</code></td>
                <td>Low-level batch resolution with Token.</td>
              </tr>
            </tbody>
          </table>

          <h3 class="mt-32 mb-16">Builder Registration</h3>
          <table class="api-params-table">
            <thead>
              <tr>
                <th style="width: 40px;"></th>
                <th>Method</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>registerType&lt;T&gt;(constructor)</code></td>
                <td>Register a class with automatic transformer-based autowiring.</td>
              </tr>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>registerInstance&lt;T&gt;(instance)</code></td>
                <td>Register an existing instance. Transformer-compatible.</td>
              </tr>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>registerFactory&lt;T&gt;(factory)</code></td>
                <td>Register a factory function. Transformer-compatible.</td>
              </tr>
              <tr>
                <td><span style="color: #6366f1; font-size: 1.2em;">🔧</span></td>
                <td><code>build()</code></td>
                <td>Build and return the configured container.</td>
              </tr>
            </tbody>
          </table>

          <h3 class="mt-32 mb-16">RegistrationBuilder (Fluent Chain)</h3>
          <table class="api-params-table">
            <thead>
              <tr>
                <th style="width: 40px;"></th>
                <th>Method</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>.as&lt;U&gt;(typeName?: string)</code></td>
                <td>Bind to interface type. Transformer injects type name.</td>
              </tr>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>.named(name: string)</code></td>
                <td>Register with a named identifier.</td>
              </tr>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>.keyed(key: any)</code></td>
                <td>Register with a keyed identifier.</td>
              </tr>
              <tr>
                <td><span style="color: #10b981; font-size: 1.2em;">✅</span></td>
                <td><code>.autoWire(options?)</code></td>
                <td>Configure automatic dependency injection. Transformer generates resolvers.</td>
              </tr>
              <tr>
                <td><span style="color: #6366f1; font-size: 1.2em;">🔧</span></td>
                <td><code>.singleInstance()</code></td>
                <td>Set lifetime to singleton (DEFAULT - no call needed).</td>
              </tr>
              <tr>
                <td><span style="color: #6366f1; font-size: 1.2em;">🔧</span></td>
                <td><code>.instancePerDependency()</code></td>
                <td>Set lifetime to transient (new instance each time).</td>
              </tr>
              <tr>
                <td><span style="color: #6366f1; font-size: 1.2em;">🔧</span></td>
                <td><code>.instancePerRequest()</code></td>
                <td>Set lifetime to per-request (one instance per resolution tree).</td>
              </tr>
            </tbody>
          </table>

          <h3 class="mt-32 mb-16">Container Management</h3>
          <table class="api-params-table">
            <thead>
              <tr>
                <th style="width: 40px;"></th>
                <th>Method</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><span style="color: #6366f1; font-size: 1.2em;">🔧</span></td>
                <td><code>createChild()</code></td>
                <td>Create a child container (for scoped resolution).</td>
              </tr>
              <tr>
                <td><span style="color: #6366f1; font-size: 1.2em;">🔧</span></td>
                <td><code>dispose()</code></td>
                <td>Dispose all disposable services in the container.</td>
              </tr>
              <tr>
                <td><span style="color: #f59e0b; font-size: 1.2em;">⚠️</span></td>
                <td><code>bindValue&lt;T&gt;(token, value, options?)</code></td>
                <td>Low-level manual value binding. Used internally by Builder.</td>
              </tr>
              <tr>
                <td><span style="color: #f59e0b; font-size: 1.2em;">⚠️</span></td>
                <td><code>bindFactory&lt;T&gt;(token, factory, options?)</code></td>
                <td>Low-level manual factory binding. Used internally by Builder.</td>
              </tr>
              <tr>
                <td><span style="color: #f59e0b; font-size: 1.2em;">⚠️</span></td>
                <td><code>bindClass&lt;T&gt;(token, constructor, options?)</code></td>
                <td>Low-level manual class binding. Used internally by Builder.</td>
              </tr>
            </tbody>
          </table>

          <h3 class="mt-32 mb-16">Token API (Low-Level)</h3>
          <table class="api-params-table">
            <thead>
              <tr>
                <th style="width: 40px;"></th>
                <th>Method</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><span style="color: #f59e0b; font-size: 1.2em;">⚠️</span></td>
                <td><code>Token&lt;T&gt;(description?: string)</code></td>
                <td>Create a type-safe token. Used internally. Not needed with transformer.</td>
              </tr>
            </tbody>
          </table>

          <div class="info-box info-box-tip mt-32">
            <h4 class="info-box-title">Legend</h4>
            <ul>
              <li><span style="color: #10b981;">✅ Transformer-based</span>: Recommended methods that work with the NovaDI transformer for automatic type injection</li>
              <li><span style="color: #f59e0b;">⚠️ Token-based</span>: Low-level methods requiring manual Token management. Used internally by the framework.</li>
              <li><span style="color: #6366f1;">🔧 Utility</span>: Helper methods for configuration and lifecycle management</li>
            </ul>
          </div>
        </section>

        <hr>

        <!-- ==================== ERRORS ==================== -->
        <section class="api-section" id="errors">
          <h2>Error Classes</h2>
          <p class="text-secondary mb-32">Specialized error types for dependency injection failures with helpful debugging information.</p>

          <!-- BindingNotFoundError -->
          <div class="api-method-card collapsed" id="binding-not-found">
            <div class="api-method-header" data-expandable>
              <div class="api-method-title-row">
                <h3 class="api-method-name">BindingNotFoundError</h3>
                <button class="api-expand-btn" aria-label="Toggle method details">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
              </div>
              <div class="api-method-signature">
                <code>throw new BindingNotFoundError(typeDescription: string, path?: string[])</code>
              </div>
              <p class="api-method-summary">Thrown when attempting to resolve a service that hasn't been registered in the container.</p>
            </div>

            <div class="api-method-body">
              <h4 class="api-section-title">Example Error Message</h4>
              <div class="api-code-block">
                <pre><code class="language-text">BindingNotFoundError: Type "ILogger" is not bound or registered in the container.
  Dependency path: IUserService -> IEmailService -> ILogger</code></pre>
              </div>

              <h4 class="api-section-title">Common Causes</h4>
              <ul>
                <li>Forgot to register the service in the container</li>
                <li>Typo in the interface type name</li>
                <li>Service registered in wrong container (parent/child issue)</li>
                <li>Missing transformer configuration (type name not injected)</li>
              </ul>

              <h4 class="api-section-title">How to Fix</h4>
              <div class="api-code-block">
                <button class="api-copy-btn" aria-label="Copy code">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  <span>Copy</span>
                </button>
                <pre><code class="language-typescript">// ❌ Error: ILogger not registered
const logger = container.resolveType&lt;ILogger&gt;()

// ✅ Fix: Register the service first
const container = new Builder()
  .registerType(ConsoleLogger).as&lt;ILogger&gt;().singleInstance()
  .build()

const logger = container.resolveType&lt;ILogger&gt;() // Works!</code></pre>
              </div>
            </div>
          </div>

          <!-- CircularDependencyError -->
          <div class="api-method-card collapsed" id="circular">
            <div class="api-method-header" data-expandable>
              <div class="api-method-title-row">
                <h3 class="api-method-name">CircularDependencyError</h3>
                <button class="api-expand-btn" aria-label="Toggle method details">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
              </div>
              <div class="api-method-signature">
                <code>throw new CircularDependencyError(path: string[])</code>
              </div>
              <p class="api-method-summary">Thrown when a circular dependency is detected (e.g., A depends on B, B depends on C, C depends on A).</p>
            </div>

            <div class="api-method-body">
              <h4 class="api-section-title">Example Error Message</h4>
              <div class="api-code-block">
                <pre><code class="language-text">CircularDependencyError: Circular dependency detected:
  IUserService -> IEmailService -> INotificationService -> IUserService</code></pre>
              </div>

              <h4 class="api-section-title">How to Fix</h4>
              <p>Break the cycle by introducing an abstraction or event-based communication:</p>
              <div class="api-code-block">
                <button class="api-copy-btn" aria-label="Copy code">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  <span>Copy</span>
                  </button>
                <pre><code class="language-typescript">// ❌ Circular: UserService → EmailService → UserService
class UserService {
  constructor(private emailService: IEmailService) {}
}
class EmailService {
  constructor(private userService: IUserService) {} // Circular!
}

// ✅ Fix: Use event bus to break cycle
class UserService {
  constructor(private eventBus: IEventBus) {}

  async createUser(email: string) {
    // ...
    this.eventBus.publish('user.created', { email })
  }
}

class EmailService {
  constructor(private eventBus: IEventBus) {
    eventBus.subscribe('user.created', this.sendWelcomeEmail)
  }

  sendWelcomeEmail(data: any) {
    // Send email...
  }
}</code></pre>
              </div>
            </div>
          </div>

        </section>

      </div>

    </main>

    <!-- Footer -->
    <footer class="main-footer">
      <div class="container">
        <p>
          <a href="https://github.com/janus007/NovaDI">View on GitHub</a> •
          <a href="https://www.npmjs.com/package/@novadi/core">npm</a> •
          <a href="https://github.com/janus007/NovaDI/issues">Report Issue</a>
        </p>
        <p class="text-secondary">Built with ❤️ for TypeScript developers</p>
      </div>
    </footer>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

    <!-- Docs JavaScript -->
    <script src="js/docs.js"></script>
    <script src="js/api-docs.js"></script>
  </body>
</html>
