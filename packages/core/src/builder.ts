/**
 * Fluent builder API for NovaDI Container (Autofac-style)
 */

import { Token } from './token.js'
import type { Container, Factory, Lifetime } from './container.js'
import { autowire } from './autowire.js'

/**
 * Represents a pending registration that hasn't been bound to a token yet
 */
interface PendingRegistration {
  type: 'type' | 'instance' | 'factory'
  value: any
  factory?: Factory<any>
  constructor?: new (...args: any[]) => any
}

/**
 * Configuration for a completed registration
 */
interface RegistrationConfig {
  token: Token<any>
  type: 'type' | 'instance' | 'factory'
  value?: any
  factory?: Factory<any>
  constructor?: new (...args: any[]) => any
  lifetime: Lifetime
  name?: string
  key?: string | symbol
  isDefault?: boolean
  ifNotRegistered?: boolean
  additionalTokens?: Token<any>[]
  dependencies?: Token<any>[] | Record<string, Token<any> | any>
  parameterValues?: Record<string, any>
  interfaceType?: string
  autowireOptions?: AutoWireOptions
}

/**
 * AutoWire configuration options
 *
 * Two strategies:
 * 1. mapResolvers (transformer-generated, optimal performance)
 * 2. map (manual override for edge cases)
 */
export interface AutoWireOptions {
  /**
   * @deprecated Legacy property - kept for backward compatibility
   * Value is ignored; strategy is automatically determined by presence of mapResolvers or map
   */
  by?: 'paramName' | 'map' | 'class' | 'positionType'

  /**
   * Strict mode: throw error if dependency cannot be resolved
   * Default: false (silently returns undefined for unresolvable dependencies)
   */
  strict?: boolean

  /**
   * Manual map object with parameter names as keys
   * Used for explicit overrides when transformer-generated mapResolvers isn't sufficient
   */
  map?: Record<string, ((c: Container) => any) | Token<any>>

  /**
   * Array of resolvers in parameter position order (transformer-generated)
   * Provides O(1) array access performance - minification-safe and refactoring-friendly
   * undefined entries indicate primitive types or parameters without DI
   * This is automatically generated by the NovaDI transformer at build time
   */
  mapResolvers?: Array<((c: Container) => any) | Token<any> | undefined>
}

/**
 * Fluent registration builder returned after each registration method
 */
export class RegistrationBuilder<T> {
  private pending: PendingRegistration
  private configs: RegistrationConfig[] = []
  private defaultLifetime: Lifetime = 'singleton'

  constructor(
    pending: PendingRegistration,
    private registrations: RegistrationConfig[]
  ) {
    this.pending = pending
  }

  /**
   * Bind this registration to a token or interface type
   *
   * @overload
   * @param {Token<U>} token - Explicit token for binding
   *
   * @overload
   * @param {string} typeName - Interface type name (auto-generated by transformer)
   */
  as<U = T>(tokenOrTypeName?: Token<U> | string): this {
    // Check if argument is a Token object (has symbol property)
    if (tokenOrTypeName && typeof tokenOrTypeName === 'object' && 'symbol' in tokenOrTypeName) {
      // Token-based registration
      const config: RegistrationConfig = {
        token: tokenOrTypeName as Token<U>,
        type: this.pending.type,
        value: this.pending.value,
        factory: this.pending.factory,
        constructor: this.pending.constructor,
        lifetime: this.defaultLifetime
      }

      this.configs.push(config)
      this.registrations.push(config)
      return this
    } else {
      // Interface-based registration (typeName string or undefined)
      const config: RegistrationConfig = {
        token: null as any, // Will be set during build()
        type: this.pending.type,
        value: this.pending.value,
        factory: this.pending.factory,
        constructor: this.pending.constructor,
        lifetime: this.defaultLifetime,
        interfaceType: tokenOrTypeName as string | undefined
      }

      this.configs.push(config)
      this.registrations.push(config)
      return this
    }
  }

  /**
   * Register as default implementation for an interface
   * Combines as() + asDefault()
   */
  asDefaultInterface<TInterface>(typeName?: string): this {
    this.as<TInterface>(typeName)
    return this.asDefault()
  }

  /**
   * Register as a keyed interface implementation
   * Combines as() + keyed()
   */
  asKeyedInterface<TInterface>(key: string | symbol, typeName?: string): this {
    this.as<TInterface>(typeName)
    return this.keyed(key)
  }

  /**
   * Register as multiple implemented interfaces
   */
  asImplementedInterfaces(tokens: Token<any>[]): this {
    if (tokens.length === 0) {
      return this
    }

    // If there are existing configs (from previous as() calls), add these as additional interfaces
    if (this.configs.length > 0) {
      // Add all tokens as additional interfaces to existing configs
      for (const config of this.configs) {
        config.lifetime = 'singleton' // asImplementedInterfaces defaults to singleton
        config.additionalTokens = config.additionalTokens || []
        config.additionalTokens.push(...tokens)
      }
      return this
    }

    // No existing configs, create new one with first token
    const firstConfig: RegistrationConfig = {
      token: tokens[0],
      type: this.pending.type,
      value: this.pending.value,
      factory: this.pending.factory,
      constructor: this.pending.constructor,
      lifetime: 'singleton'
    }

    this.configs.push(firstConfig)
    this.registrations.push(firstConfig)

    // Additional tokens reference the same registration
    for (let i = 1; i < tokens.length; i++) {
      firstConfig.additionalTokens = firstConfig.additionalTokens || []
      firstConfig.additionalTokens.push(tokens[i])
    }

    return this
  }

  /**
   * Set singleton lifetime (one instance for entire container)
   */
  singleInstance(): this {
    for (const config of this.configs) {
      config.lifetime = 'singleton'
    }
    return this
  }

  /**
   * Set per-request lifetime (one instance per resolve call tree)
   */
  instancePerRequest(): this {
    for (const config of this.configs) {
      config.lifetime = 'per-request'
    }
    return this
  }

  /**
   * Set transient lifetime (new instance every time)
   * Alias for default behavior
   */
  instancePerDependency(): this {
    for (const config of this.configs) {
      config.lifetime = 'transient'
    }
    return this
  }

  /**
   * Name this registration for named resolution
   */
  named(name: string): this {
    for (const config of this.configs) {
      config.name = name
    }
    return this
  }

  /**
   * Key this registration for keyed resolution
   */
  keyed(key: string | symbol): this {
    for (const config of this.configs) {
      config.key = key
    }
    return this
  }

  /**
   * Mark this as default registration
   * Default registrations don't override existing ones
   */
  asDefault(): this {
    for (const config of this.configs) {
      config.isDefault = true
    }
    return this
  }

  /**
   * Only register if token not already registered
   */
  ifNotRegistered(): this {
    for (const config of this.configs) {
      config.ifNotRegistered = true
    }
    return this
  }

  /**
   * Specify parameter values for constructor (primitives and constants)
   * Use this for non-DI parameters like strings, numbers, config values
   */
  withParameters(parameters: Record<string, any>): this {
    for (const config of this.configs) {
      config.parameterValues = parameters
    }
    return this
  }

  /**
   * Enable automatic dependency injection (autowiring)
   * Supports three strategies: paramName (default), map, and class
   *
   * @example
   * ```ts
   * // Strategy 1: paramName (default, requires non-minified code in dev)
   * builder.registerType(EventBus).as<IEventBus>().autoWire()
   *
   * // Strategy 2: map (minify-safe, explicit)
   * builder.registerType(EventBus).as<IEventBus>().autoWire({
   *   map: {
   *     logger: (c) => c.resolveType<ILogger>()
   *   }
   * })
   *
   * // Strategy 3: class (requires build-time codegen)
   * builder.registerType(EventBus).as<IEventBus>().autoWire({ by: 'class' })
   * ```
   */
  autoWire(options?: AutoWireOptions): this {
    for (const config of this.configs) {
      config.autowireOptions = options || { by: 'paramName', strict: false }
    }
    return this
  }
}

/**
 * Module function type - allows organizing registrations
 */
export type Module = (builder: Builder) => void

/**
 * Fluent builder for Container configuration
 */
export class Builder {
  private registrations: RegistrationConfig[] = []

  constructor(private readonly baseContainer: Container) {}

  /**
   * Register a class constructor
   */
  registerType<T>(constructor: new (...args: any[]) => T): RegistrationBuilder<T> {
    const pending: PendingRegistration = {
      type: 'type',
      value: null,
      constructor
    }

    return new RegistrationBuilder(pending, this.registrations)
  }

  /**
   * Register a pre-created instance
   */
  registerInstance<T>(instance: T): RegistrationBuilder<T> {
    const pending: PendingRegistration = {
      type: 'instance',
      value: instance,
      constructor: undefined
    }

    return new RegistrationBuilder(pending, this.registrations)
  }

  /**
   * Register a factory function
   */
  register<T>(factory: Factory<T>): RegistrationBuilder<T> {
    const pending: PendingRegistration = {
      type: 'factory',
      value: null,
      factory,
      constructor: undefined
    }

    return new RegistrationBuilder(pending, this.registrations)
  }

  /**
   * Register a module (function that adds multiple registrations)
   */
  module(moduleFunc: Module): this {
    moduleFunc(this)
    return this
  }

  /**
   * Resolve interface type names to tokens
   * @internal
   */
  private resolveInterfaceTokens(container: Container): void {
    for (const config of this.registrations) {
      if (config.interfaceType !== undefined && !config.token) {
        config.token = container.interfaceToken(config.interfaceType)
      }
    }
  }

  /**
   * Identify tokens that have non-default registrations
   * @internal
   */
  private identifyNonDefaultTokens(): Set<Token<any>> {
    const tokensWithNonDefaults = new Set<Token<any>>()
    for (const config of this.registrations) {
      if (!config.isDefault && !config.name && config.key === undefined) {
        tokensWithNonDefaults.add(config.token)
      }
    }
    return tokensWithNonDefaults
  }

  /**
   * Check if registration should be skipped
   * @internal
   */
  private shouldSkipRegistration(
    config: RegistrationConfig,
    tokensWithNonDefaults: Set<Token<any>>,
    registeredTokens: Set<Token<any>>
  ): boolean {
    // Skip default registrations if there's a non-default for the same token
    if (config.isDefault && !config.name && config.key === undefined && tokensWithNonDefaults.has(config.token)) {
      return true
    }

    // Handle ifNotRegistered
    if (config.ifNotRegistered && registeredTokens.has(config.token)) {
      return true
    }

    // Handle asDefault
    if (config.isDefault && registeredTokens.has(config.token)) {
      return true
    }

    return false
  }

  /**
   * Create binding token for registration (named, keyed, or multi)
   * @internal
   */
  private createBindingToken(
    config: RegistrationConfig,
    namedRegistrations: Map<string, any>,
    keyedRegistrations: Map<string | symbol, any>,
    multiRegistrations: Map<Token<any>, Token<any>[]>
  ): Token<any> {
    if (config.name) {
      // Named registration gets unique token
      const bindingToken = Token(`__named_${config.name}`)
      namedRegistrations.set(config.name, { ...config, token: bindingToken })
      return bindingToken
    } else if (config.key !== undefined) {
      // Keyed registration gets unique token
      const keyStr = typeof config.key === 'symbol' ? config.key.toString() : config.key
      const bindingToken = Token(`__keyed_${keyStr}`)
      keyedRegistrations.set(config.key, { ...config, token: bindingToken })
      return bindingToken
    } else {
      // Multi-registration handling
      if (multiRegistrations.has(config.token)) {
        // Subsequent registration for this token
        const bindingToken = Token(`__multi_${config.token.toString()}_${multiRegistrations.get(config.token)!.length}`)
        multiRegistrations.get(config.token)!.push(bindingToken)
        return bindingToken
      } else {
        // First registration for this token, use the original token
        multiRegistrations.set(config.token, [config.token])
        return config.token
      }
    }
  }

  /**
   * Register additional interfaces for a config
   * @internal
   */
  private registerAdditionalInterfaces(
    container: Container,
    config: RegistrationConfig,
    bindingToken: Token<any>,
    registeredTokens: Set<Token<any>>
  ): void {
    if (config.additionalTokens) {
      for (const additionalToken of config.additionalTokens) {
        // Create a factory that resolves the binding token
        container.bindFactory(
          additionalToken,
          (c) => c.resolve(bindingToken),
          { lifetime: config.lifetime }
        )
        registeredTokens.add(additionalToken)
      }
    }
  }

  /**
   * Build the container with all registered bindings
   */
  build(): Container {
    // Create new container inheriting from base
    const container = this.baseContainer.createChild()

    // Pre-process: resolve interface types to tokens
    this.resolveInterfaceTokens(container)

    // Track what's been registered for ifNotRegistered checks
    const registeredTokens = new Set<Token<any>>()
    const namedRegistrations = new Map<string, any>()
    const keyedRegistrations = new Map<string | symbol, any>()
    const multiRegistrations = new Map<Token<any>, Token<any>[]>()

    // Pre-process: identify tokens that have non-default registrations
    const tokensWithNonDefaults = this.identifyNonDefaultTokens()

    for (const config of this.registrations) {
      // Check if registration should be skipped
      if (this.shouldSkipRegistration(config, tokensWithNonDefaults, registeredTokens)) {
        continue
      }

      // Create binding token (named, keyed, or multi)
      const bindingToken = this.createBindingToken(
        config,
        namedRegistrations,
        keyedRegistrations,
        multiRegistrations
      )

      // Apply registration to container using the binding token
      this.applyRegistration(container, { ...config, token: bindingToken })

      // Mark original token as registered
      registeredTokens.add(config.token)

      // Register additional interfaces
      this.registerAdditionalInterfaces(container, config, bindingToken, registeredTokens)
    }

    // Attach metadata for named/keyed resolution
    ;(container as any).__namedRegistrations = namedRegistrations
    ;(container as any).__keyedRegistrations = keyedRegistrations
    ;(container as any).__multiRegistrations = multiRegistrations

    return container
  }

  /**
   * Analyze constructor to detect dependencies
   * @internal
   */
  private analyzeConstructor(constructor: new (...args: any[]) => any): {
    hasDependencies: boolean
  } {
    const constructorStr = constructor.toString()
    const hasDependencies = /constructor\s*\([^)]+\)/.test(constructorStr)
    return { hasDependencies }
  }

  /**
   * Create optimized factory for zero-dependency constructors
   * @internal
   */
  private createOptimizedFactory(
    container: Container,
    config: RegistrationConfig,
    options: { lifetime: Lifetime }
  ): void {
    if (config.lifetime === 'singleton') {
      // Singleton: Create instance directly (fastest path - no factory overhead)
      const instance = new config.constructor!()
      container.bindValue(config.token, instance)
    } else if (config.lifetime === 'transient') {
      // Transient Fast Path: Register in fast transient cache
      const ctor = config.constructor!
      const fastFactory = () => new ctor()
      ;(container as any).fastTransientCache.set(config.token, fastFactory)
      container.bindFactory(config.token, fastFactory, options)
    } else {
      // Per-request: Use simple factory without autowire overhead
      const factory: Factory<any> = () => new config.constructor!()
      container.bindFactory(config.token, factory, options)
    }
  }

  /**
   * Create autowire factory
   * @internal
   */
  private createAutoWireFactory(
    container: Container,
    config: RegistrationConfig,
    options: { lifetime: Lifetime }
  ): void {
    const factory: Factory<any> = (c) => {
      const resolvedDeps = autowire(config.constructor!, c, config.autowireOptions)
      return new config.constructor!(...resolvedDeps)
    }
    container.bindFactory(config.token, factory, options)
  }

  /**
   * Create withParameters factory
   * @internal
   */
  private createParameterFactory(
    container: Container,
    config: RegistrationConfig,
    options: { lifetime: Lifetime }
  ): void {
    const factory: Factory<any> = () => {
      const values = Object.values(config.parameterValues!)
      return new config.constructor!(...values)
    }
    container.bindFactory(config.token, factory, options)
  }

  /**
   * Apply type registration (class constructor)
   * @internal
   */
  private applyTypeRegistration(
    container: Container,
    config: RegistrationConfig,
    options: { lifetime: Lifetime }
  ): void {
    const { hasDependencies } = this.analyzeConstructor(config.constructor!)

    // Fast path: No dependencies and no special config
    if (!hasDependencies && !config.autowireOptions && !config.parameterValues) {
      this.createOptimizedFactory(container, config, options)
      return
    }

    // AutoWire path
    if (config.autowireOptions) {
      this.createAutoWireFactory(container, config, options)
      return
    }

    // withParameters path
    if (config.parameterValues) {
      this.createParameterFactory(container, config, options)
      return
    }

    // Error: Constructor has dependencies but no config
    if (hasDependencies) {
      const className = config.constructor!.name || 'UnnamedClass'
      throw new Error(
        `Service "${className}" has constructor dependencies but no autowiring configuration.\n\n` +
        `Solutions:\n` +
        `  1. ⭐ Use the NovaDI transformer (recommended):\n` +
        `     - Add "@novadi/core/unplugin" to your build config\n` +
        `     - Transformer automatically generates .autoWire() for all dependencies\n\n` +
        `  2. Add manual autowiring:\n` +
        `     .autoWire({ map: { /* param: resolver */ } })\n\n` +
        `  3. Use a factory function:\n` +
        `     .register((c) => new ${className}(...))\n\n` +
        `See docs: https://github.com/janus007/NovaDI#autowire`
      )
    }

    // No dependencies - create simple factory
    const factory: Factory<any> = () => new config.constructor!()
    container.bindFactory(config.token, factory, options)
  }

  private applyRegistration(container: Container, config: RegistrationConfig): void {
    const options = { lifetime: config.lifetime }

    switch (config.type) {
      case 'instance':
        container.bindValue(config.token, config.value)
        break

      case 'factory':
        container.bindFactory(config.token, config.factory!, options)
        break

      case 'type':
        this.applyTypeRegistration(container, config, options)
        break
    }
  }
}
